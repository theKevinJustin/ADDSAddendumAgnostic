<?xml version="1.0" encoding="utf-8"?><ManagementPack ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="1.1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <Manifest>
    <Identity>
      <ID>Microsoft.Windows.Server.AD.2016.Monitoring.Addendum</ID>
      <Version>1.0.4.7</Version>
    </Identity>
    <Name>Microsoft Windows Server AD 2016 Monitoring Addendum</Name>
    <References>
      <Reference Alias="Health">
        <ID>System.Health.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWSA6D">
        <ID>Microsoft.Windows.Server.AD.2016.Discovery</ID>
        <Version>10.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWSA6M">
        <ID>Microsoft.Windows.Server.AD.2016.Monitoring</ID>
        <Version>10.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWSAL">
        <ID>Microsoft.Windows.Server.AD.Class.Library</ID>
        <Version>10.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SC">
        <ID>Microsoft.SystemCenter.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="System">
        <ID>System.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Windows">
        <ID>Microsoft.Windows.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
    </References>
  </Manifest>
  <TypeDefinitions>
    <ModuleTypes>
      <DataSourceModuleType ID="Proactive.DailyTasks.ADDSAlerts.Close.Script.DataSource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>06:16</Start>
                        <End>06:36</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.DailyTasks.ADDSAlerts.Close.Script.Datasource.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather ADDS alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.ADDSAlerts.Close.Script.Datasource.v1047.ps1"
$EventID = "550"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts Close Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-7)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive DailyTasks ADDS Monitors close automation for ($date).")
$Message = "Proactive DailyTasks ADDS Monitors close automation for ($date)."


# Gather AD alerts
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "Active Directory Domain Services for Microsoft Windows Server 2016 and above (Monitoring)"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

# Open/Closed breakout
$OpenADDSAlerts = $SCOMCoreReportAlerts
$OpenADDSAlerts.Count
$ClosedADDSAlerts = Get-SCOMAlert -ResolutionState 255 | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$ClosedADDSAlerts.Count

# Debug - display alerts by server, alert description
#$ADDSAlerts = $SCOMCoreReportAlerts | select MonitoringObjectDisplayName,Description


# Build report
#==========================================================

if ( $SCOMCoreReportAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for ADDS alert closure workflow for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	#
	# Build report
	$ADDSComponentMessage = @()
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += $Message
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += "# ADDS Monitors auto-closed"
	$ADDSComponentMessage += "#============================================================"
	$ADDSComponentMessage += "# Total ADDS alerts = $($SCOMCoreReportAlerts.Count)"
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# Open alerts = $($OpenADDSAlerts.Count)"
	$ADDSComponentMessage += "# Closed alerts = $($ClosedADDSAlerts.Count)"
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# Automation closed alerts = $($OpenADDSAlerts.Count)"
	$ADDSComponentMessage += "#========================================="
	$ADDSComponentMessage += ""
	}

$ADDSComponentMessage

$ADDSComponentMessage = $ADDSComponentMessage | out-string


# Log data event before resetting monitors
#============================================================
  $Result = "GOOD"

  $momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS Monitors close automation for ($date).")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$ADDSComponentMessage)

# Return all bags
$bag



#=================================================================================
# Reset Monitors Script base code modified
# Put ps1 in mgmtpacks folder
# https://sc.scomurr.com/scom-2012-monitor-reset-cleaning-up-the-environment/
#	Download
# https://gallery.technet.microsoft.com/SCOM-2012-Batch-reset-63a17534
	
#Alternate
#https://gallery.technet.microsoft.com/scriptcenter/Auto-reset-script-for-d8b775ca

# Changed up logic to sort unique classes in mgmnt pack families.
# Added Age variable for monitors thanks to Aris Somatis - $Age specified in top level variables
# Cycling through monitors made reset loop huge ~650 monitors when only ~50 classes
# New logic reduced runtime from 8 minutes to roughly 8 seconds
#=================================================================================

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS Monitors reset started for ($date).")


if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	# Get AD classes - Microsoft.Windows.Server.AD.2016.Discovery, Microsoft.Windows.Server.AD.Library
		$ADLibrary = Get-SCOMManagementPack -name "Microsoft.Windows.Server.AD.Class.Library"
			#get-scomclass -ManagementPack $ADLibrary
		$ADMonitoring = $SCOMCoreMP
			# Get-SCOMManagementPack -name "Microsoft.Windows.Server.AD.2016.Monitoring"
			# get-scomclass -ManagementPack $ADMonitoring | fl DisplayName,Name,ID
		$ADDiscovery = Get-SCOMManagementPack -name Microsoft.Windows.Server.AD.2016.Discovery
			#get-scomclass -ManagementPack $ADDiscovery | fl DisplayName,Name,ID

	# ADDS pack naming
	$ADDSClasses = @(Get-SCOMClass -ManagementPack $ADLibrary; Get-SCOMClass -ManagementPack $ADDiscovery; )
	$ADDSClass = $ADDSClasses | sort -property Name -uniq
	# Debug
	$ADDSClass.Count

	# Set up monitor objects to reset
	foreach ($Class in $ADDSClass)
		{
		$ActiveMonitors = @(Get-SCOMClassInstance -Class $Class | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) } )
		# Debug
		$ActiveMonitors.Count
		# $ActiveMonitors | fl -property *
		write-host "Found" $ActiveMonitors.Count "unhealthy monitors for class" $Class
		foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
			{
			#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
			if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
				{
				#$UnhealthyMonitors += $ActiveMonitors.Count
				#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
				#$UnhealthyOLDMonitor.Count
				#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
				#write-host ""
				if ( $ActiveMonitors.Count -gt 0)
					{
					foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
						{
						# Debug
						$ActiveMonitor.ID
						write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
						write-host ""
						$ActiveMonitor.ResetMonitoringState($ActiveMonitor.ID)
						}
					}
				}
			}
		}
	# Debug
	#$MonitorClass | fl -property *
	#$MonitorClass | select DisplayName,ID
	}


# Debug Write event for rule closure
#=================================================================================
# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS monitor reset completed for ($date)")


# Rule closure logic
#=================================================================================
$SCOMCoreRulesToClear = $SCOMCoreRuleAlerts | where { ( $_.TimeAdded -lt $Age ) }
# Convert Age back to days for alert properties logging
$Days = ((Get-date) - $Age).Days
if ( $SCOMCoreRulesToClear.Count -gt 0 )
	{
	$SCOMCoreRulesToClear | Resolve-SCOMAlert -Comment "Closing $Days day old alerts after report alert generated - ADDS Addendum Automation DS"
	}

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS rule reset completed for ($date)")


#=================================================================================
# End MAIN script section
 
  
# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts Close Script Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.DataSource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>05:11</Start>
                        <End>05:31</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.DataSource.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather ADDS alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.DataSource.v1047.ps1"
$EventID = "552"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts SummaryReport Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather ADDS Alerts for date ($date).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


# Gather AD alerts
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "Active Directory Domain Services for Microsoft Windows Server 2016 and above (Monitoring)"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

$Test = $SCOMCoreReportAlerts.Count


$OpenADDSAlerts = $SCOMCoreReportAlerts
$OpenADDSAlerts.Count
$ClosedADDSAlerts = Get-SCOMAlert -ResolutionState 255  | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$ClosedADDSAlerts.Count


# Break out AD site alerts
# AD Site Performance Health Degraded
# AD Site Availability Health Degraded
$ADDSSiteAlerts = get-scomalert -ResolutionState (0..254) | ? { ( $_.Name -eq "AD Site Performance Health Degraded" ) `
	-OR ( $_.Name -eq "AD Site Availability Health Degraded" ) `
	} | ? { $_.ResolutionState -ne "255"}
	
$ADDSSiteAlerts = $ADDSSiteAlerts | sort -property MonitoringObjectDisplayName -uniq | select MonitoringObjectDisplayName,TimeRaised


# Break out GPO alert section
$GPOAlerts = $(get-scomalert -name "The Group Policy Update health monitor has failed." -ResolutionState (0..254) ).Description

$GPOAlertsDesc = $GPOAlerts.Description
$GPOAlertsDesc.Count

$GPOService = get-scomalert -name "Group Policy Client Service Not Running" -ResolutionState (0..254)
$GPOService.Count

$GPAlerts = $GPOAlerts.count + $GPOService.Count

$GPOErrors = @()

if ( $GPOAlerts.Count -gt 0 )
	{
	foreach ($LLine in $GPOAlerts)
	{
	$LLine; $Lmatch = $LLine |select-string -pattern ':'
	if ($Lmatch)
		{
		#$Lmatch
		$LLineSplit = $LLine.Split(":")
		#write-host "field 2"; $LLineSplit[2]
		$LLine2 = $LLineSplit[2].Split(".")
			write-host "split 2 field 0"; $LLine2[0]
			#write-host "split 2 field 1"; $LLine2[1]
			#write-host "split 2 field 2"; $LLine2[2]
			write-host "split 2 field 3"; $LLine2[3]
			#write-host "split 2 field 4"; $LLine2[4]
			#write-host "split 2 field 5"; $LLine2[5]
			write-host "split 2 field 6"; $LLine2[6]
			#write-host "split 2 field 7"; $LLine2[7]
			write-host "split 2 field 8"; $LLine2[8]
			#write-host "split 2 field 9"; $LLine2[9]
			#write-host "split 2 field 10"; $LLine2[10]
			write-host "split 2 field 11"; $LLine2[11]
		$GPOErrors += $LLine2[0]
		$GPOErrors += $LLine2[3]
		$GPOErrors += $LLine2[6]
		$GPOErrors += $LLine2[8]
		$GPOErrors += $LLine2[11]
		}
	}
}

$GPOErrors

#$GPOErrors.where({ $_ -ne ""})

$Strings = @()
$Strings += "html from the command line to access information about Group Policy results"
$Strings += "The following warnings were encountered"
$Strings += "The processing of Group Policy failed"
$Strings += "User Policy update"
$Strings += "View the event details"
$Strings += "Windows failed to apply the Microsoft Disk Quota settings"
$Strings += "Windows failed to apply the {F312195E-3D9D-447A-A3F5-08DFFA24735E} settings"

#$GPOErrors | ? { ($_.Name -in $Strings) }
$UniqGPOErrors = $GPOErrors | ? { ($_.Name -in $Strings) }

$UniqErrors = $UniqGPOErrors | out-string


# Build out ADDS Time Skew monitors
$ADDSTimeSkew = $SCOMCoreReportAlerts | ? { $_.Name -eq "The Time Skew monitor has failed." `
	} |sort -property NetBiosComputerName
$ADDSTimeSkew.Count


# ADDSATQ
# Build out LSASS process with high CPU alerts
$ADDSATQ = $SCOMCoreReportAlerts | ? { $_.Name -like "The total number of ATQ threads in use has exceeded*" `
	} | sort -property NetBiosComputerName | select NetBiosComputerName,TimeRaise
$ADDSATQ.Count


# Build out LSASS process with high CPU alerts
$ADDSLSASS = $SCOMCoreReportAlerts | ? { $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." `
	} | sort -property NetBiosComputerName | select NetBiosComputerName,TimeRaise
$ADDSLSASS.Count


# Build out Replication alerts
# The AD Replication Queue health monitor has exceeded one or more thresholds.
# AD Show Replication Check health monitor has failed.
# Replication Partner Count health monitor has failed.

$ADDSReplAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -eq "The AD Replication Queue health monitor has exceeded one or more thresholds." ) `
	-OR ( $_.Name -eq "AD Show Replication Check health monitor has failed.") `
	-OR ( $_.Name -eq "Replication Partner Count health monitor has failed." ) `
	} |sort -property NetBiosComputerName | select NetBiosComputerName,TimeRaise 
$ADDSReplAlerts.Count

# Build out remaining ADDS alerts
$Remaining = $SCOMCoreReportAlerts | ? { ( $_.Name -ne "The Group Policy Update health monitor has failed." ) `
	-AND ( $_.Name -ne "AD Show Replication Check health monitor has failed.") `
	-AND ( $_.Name -ne "AD Show The Group Policy Update health monitor has failed.") `
	-AND ( $_.Name -ne "AD Site Performance Health Degraded" ) `
	-AND ( $_.Name -ne "AD Site Availability Health Degraded" ) `
	-AND ( $_.Name -ne "Replication Partner Count health monitor has failed." ) `
	-AND ( $_.Name -ne "The AD Replication Queue health monitor has exceeded one or more thresholds." ) `
	-AND ( $_.Name -ne "The Group Policy Update health monitor has failed." ) `
	-AND ( $_.Name -ne "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-AND ( $_.Name -ne "The Network Adapters DNS Servers health monitor has failed." ) `
	-AND ( $_.Name -ne "The Time Skew monitor has failed." ) `
	-AND ( $_.Name -ne "The total number of ATQ threads in use has exceeded one or more thresholds over multiple samples." ) `
	}
	
$Remaining.Count
$Remaining


# Build report
$ADDSMessage = @()

$ADDSMessage += ""

# Show ADDS alerts by Time Raised,NetBiosComputerName,Message
#
$ADDSMessage += "# ADDS Alert report for $($date)"
$ADDSMessage += "#"
$ADDSMessage += "# Count of NEW ADDS alerts = $($SCOMCoreReportAlerts.Count)"
$ADDSMessage += "#========================================================"
$ADDSMessage += ""


if ( $ADDSTimeSkew.Count -eq 0 )
	{
	$ADDSMessage += "ZERO NTP Time Skew monitors on Domain Controllers"
	$ADDSMessage += ""
	}
	
if ( $ADDSTimeSkew.Count -gt 0 )
	{
	$ADDSMessage += "# NTP Time Skew monitors on Domain Controllers"
	$ADDSMessage += "#============================================="
	if ( $ADDSTimeSkew.Count -lt 10 )
		{
		$ADDSMessage += $ADDSTimeSkew | select NetBiosComputerName,TimeRaised -auto
		}
	if ( $ADDSTimeSkew.Count -ge 10 )
		{
		$ADDSMessage += "The number of Time Skew alerts exceeds 10 since the last report execution"
		}
	$ADDSMessage += "#========================"
	$ADDSMessage += ""
	}


if ( $ADDSATQ.Count -eq 0 )
	{
	$ADDSMessage += "ZERO ADDS Servers with ATQ thread issues"
	$ADDSMessage += ""
	}

if ( $ADDSATQ.Count -gt 0 )
	{
	$ADDSMessage += "# ADDS Servers with ATQ thread issues"
	$ADDSMessage += "#=================================="
	if ( $ADDSATQ.Count -lt 10 )
		{
		$ADDSMessage += $ADDSATQ
		}
	if ( $ADDSATQ.Count -ge 10 )
		{
		$ADDSMessage += "The number of DC's reporting ATQ Thread issues exceeds 10 since the last report execution"
		}
	$ADDSMessage += "#========================"
	$ADDSMessage += ""
	}
	
	
if ( $ADDSLSASS.Count -eq 0 )
	{
	$ADDSMessage += "ZERO LSASS processes with high CPU"
	$ADDSMessage += ""
	}

if ( $ADDSLSASS.Count -gt 0 )
	{
	$ADDSMessage += "# LSASS process has high CPU alerts"
	$ADDSMessage += "#=================================="
	if ( $ADDSLSASS.Count -lt 10 )
		{
		$ADDSMessage += $ADDSLSASS
		}
	if ( $ADDSLSASS.Count -ge 10 )
		{
		$ADDSMessage += "The number of DC's reporting high CPU on LSASS.exe process exceeds 10 since the last report execution"
		}
	$ADDSMessage += "#========================"
	$ADDSMessage += ""
	}


if ( $ADDSReplAlerts.Count -eq 0 )
	{
	$ADDSMessage += "ZERO ADDS Replication alerts"
	$ADDSMessage += ""
	}
	
if ( $ADDSReplAlerts.Count -gt 0 )
	{
	$ADDSMessage += "# ADDS replication alerts"
	$ADDSMessage += "#========================"
	if ( $ADDSReplAlerts.Count -ge 10 )
		{
		$ADDSMessage += "The number of replication alerts exceeds 10 since the last report execution"
		$ADDSMessage += ""
		}
	if ( $ADDSReplAlerts.Count -lt 10 )
		{
		$ADDSMessage += $ADDSReplAlerts
		$ADDSMessage += ""
		}	
	$ADDSMessage += "#==================="
	$ADDSMessage += ""
	}


# GPO alerts
if ( $GPAlerts -gt 0 )
	{
	$ADDSMessage += "ZERO ADDS Group Policy (GPO) alerts"
	$ADDSMessage += ""
	}

if ( $GPAlerts -gt 0 )
	{
	$ADDSMessage += "# Group Policy alerts"
	$ADDSMessage += "#===================="
	$ADDSMessage += "# Total GPO alerts = ($GPAlerts)"
	$ADDSMessage += "#"
	$ADDSMessage += "# Break out of GPO alerts specifically for 'Group Policy Update failed' alerts = $($GPOAlerts.count)"
	$ADDSMessage += "#"
	$ADDSMessage += "#"
	$ADDSMessage += "# Unique GPO errors in past 24 hours"
	$ADDSMessage += "#==================================="
	$ADDSMessage += "$UniqErrors"
	$ADDSMessage += ""
	}
	
if ( $GPOService.Count -eq 0 )
	{
	$ADDSMessage += "ZERO ADDS GPO Service down alerts"
	$ADDSMessage += ""
	}

if ( $GPOService.Count -gt 0 )
	{
	$ADDSMessage += "#================================================================="
	$ADDSMessage += "# GPO service not running - Affected servers (date/time alert cut)"
	$ADDSMessage += "#================================================================="
	$ADDSMessage += $GPOService | select NetbiosComputerName,TimeRaised -auto
	$ADDSMessage += "#================================================================="
	$ADDSMessage += ""
	}


# Remaining ADDS alerts
if ( $Remaining.Count -gt 0 )
	{
	$ADDSMessage += "ZERO Remaining ADDS alerts"
	$ADDSMessage += ""
	}
	
if ( $Remaining.Count -gt 0 )
	{
	$ADDSMessage += "# Remaining ADDS alerts"
	$ADDSMessage += "#========================================================"
	if ( $Remaining.Count -ge 10 )
		{
		$ADDSMessage += "The number of remaining ADDS alerts exceeds 10 since the last report execution"
		$ADDSMessage += ""
		}
	if ( $Remaining.Count -lt 10 )
		{
		$ADDSMessage += ($Remaining | sort -property Name | select TimeRaised,NetbiosComputerName,Name)
		$ADDSMessage += ""
		}
	$ADDSMessage += ""
	$ADDSMessage += "#========================================================"
	$ADDSMessage += ""
	}

$ADDSMessage

$ADDSMessage = $ADDSMessage | out-string


#============================================================

  $Result = "GOOD"
  $Message = "Daily ADDS alerts report for ($date)"

  $momapi.LogScriptEvent($ScriptName,$EventID,0,"ADDS Monitors auto-closed for ($date). `n `n$ADDSMessage")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$ADDSMessage)


# Return all bags
$bag
#=================================================================================
# End MAIN script section
 
  
# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts SummaryReport Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.Datasource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>06:02</Start>
                        <End>06:22</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.Datasource.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather ADDS alerts for team daily report
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.Datasource.v1047.ps1"
$EventID = "563"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive Microsoft Windows Server Addendum AD 2016 Reports Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather ADDS Alerts for date ($date).")
  $Message = "AD Team Daily report for ($date)"


# Gather ADDS alerts
# Monitors then rules
$ADDSReportAlerts = get-scomalert | ? { ( $_.Name -eq "Available Megabytes of Memory is too low" ) `
	-OR ( $_.Name -eq "Certificate lifespan alert" ) `
	-OR ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -like "DFS-R: *" ) `
	-OR ( $_.Name -like "DHCP*" ) `
	-OR ( $_.Name -eq "DHCP Service Stopped" ) `
	-OR ( $_.Name -eq "Disk read latency  is too high" ) `
	-OR ( $_.Name -eq "Disk write latency  is too high" ) `
	-OR ( $_.Name -eq "DNS Client Service Stopped" ) `
	-OR ( $_.Name -eq "Event log is full" ) `
	-OR ( $_.Name -eq "Fail to access site system alert" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Failed to install application on client" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Free System Page Table Entries is too Low." ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -eq "IP address conflict" ) `
	-OR ( $_.Name -eq "LDM - Can't Read Disk" ) `
	-OR ( $_.Name -eq "Logical Disk Fragmentation Level is high" ) `
	-OR ( $_.Name -eq "Logical Disk Free Space is low" ) `
	-OR ( $_.Name -eq "Logical disk idle time percentage is too low" ) `
	-OR ( $_.Name -eq "Logical disk current queue length is too high" ) `
	-OR ( $_.Name -eq "Logical disk transfer (reads and writes) latency  is too high" ) `
	-OR ( $_.Name -eq "Max Concurrent API Reached alert" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Network Adapter Disconnected" ) `
	-OR ( $_.Name -like "Tangible ProV ProVService Service*" ) `
	-OR ( $_.Name -eq "NTFS - File System Corrupt" ) `
	-OR ( $_.Name -eq "NTFS reported the logical disk is in error or corrupt." ) `
	-OR ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -like "PROACTIVE*" ) `
	-OR ( $_.Name -eq "Service entered unpredictable state" ) `
	-OR ( $_.Name -eq "Service is misconfigured" ) `
	-OR ( $_.Name -eq "Service or driver failed to start" ) `
	-OR ( $_.Name -eq "Server Service is misconfigured" ) `
	-OR ( $_.Name -eq "Service terminated unexpectedly" ) `
	-OR ( $_.Name -eq "Share configuration is invalid" ) `
	-OR ( $_.Name -eq "Software update installation failed" ) `
	-OR ( $_.Name -eq "TCP/IP NetBIOS Service Stopped" ) `
	-OR ( $_.Name -eq "The LDAP Bind Time health monitor has exceeded one or more thresholds." ) `
	-OR ( $_.Name -eq "Too many requests for performance counter data have timed out" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "Total DPC Time Percentage is too high" ) `
	-OR ( $_.Name -eq "Total Percentage Interrupt Time is too high" ) `
	-OR ( $_.Name -eq "Used total bandwidth is over threshold" ) `
	-OR ( $_.Name -eq "Used write bandwidth is over threshold" ) `
	-OR ( $_.Name -like "Windows DNS *" ) `
	-OR ( $_.Name -eq "Windows Event Log Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Firewall Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Remote Management Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Required Activation" ) `
	-OR ( $_.Name -eq "Windows Server Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "The Group Policy Update health monitor has failed." ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	}  # | ? { ( $_.TimeRaised -ge $Time ) }

$ADDSReportAlerts.Count


# Open ADDS server alerts
$ADDSServerAlerts = $ADDSReportAlerts | ? { ( $_.NetBiosComputerName -like "DC0*" ) `
	-OR ( $_.NetBiosComputerName -like "*W4NHAAH7*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAA0*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAA1*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAA4*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAA7*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAC1*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AADH*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH0*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH1*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH2*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH3*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH4*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH6*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH8*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAK9*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "DC0*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W4NHAAH7*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAA0*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAA1*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAA4*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAA7*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAC1*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AADH*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH0*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH1*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH2*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH3*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH4*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH6*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH8*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAK9*" ) `
	}

# $ADDSServerAlerts 
# $ADDSServerAlerts.Count


# Open ADDS server alerts
$ADDSOpenAlerts = $ADDSServerAlerts | where { $_.ResolutionState -ne "255" }
# $ADDSOpenAlerts.Count

# Open ADDS server alerts since last report
$ADDSAlertsSinceReport = $ADDSOpenAlerts | where { ( $_.TimeRaised -ge $Time ) }
# $ADDSAlertsSinceReport.Count


# Closed ADDS server alerts
$ADDSClosedAlerts = $ADDSServerAlerts | where { $_.ResolutionState -eq "255" }
# $ADDSClosedAlerts.Count

# Closed ADDS server alerts since last report
$ADDSAlertsSinceReport = $ADDSClosedAlerts | where { ( $_.TimeRaised -ge $Time ) }
# $ADDSAlertsSinceReport.Count

$ClosedADDSAlerts = $ADDSClosedAlerts 
# $ClosedADDSAlerts.Count




#
# PROACTIVE - Server restart pending detected
$PendingRestart = $ADDSServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	}

#$PendingRestart.Count

$PendingRestart = $PendingRestart | select NetbiosComputerName,TimeRaised

$OpenPendingRestart = $PendingRestart
# $OpenPendingRestart.Count

$ClosedPendingRestart = $ClosedADDSAlert | ? { ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) }
# $ClosedPendingRestart.Count


#
# PROACTIVE - Server NOT rebooted in past month
$NotRebooted = $ADDSServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) }

#$NotRebooted.Count
$NotRebooted = $NotRebooted | select NetbiosComputerName,TimeRaised

$OpenNotRebooted = $NotRebooted
# $OpenNotRebooted.Count

$ClosedNotRebooted = $ClosedADDSAlert | ? { ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) }
#$ClosedNotRebooted.Count


#
# PROACTIVE - Server NOT patched in past month
$NotPatched = $ADDSServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) }

$NotPatched = $NotPatched | select NetbiosComputerName,TimeRaised

$OpenNotPatched = $NotPatched
#$OpenNotPatched.Count

$ClosedNotPatched = $ClosedADDSAlert | ? { ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) }
#$ClosedNotPatched.Count


# Tangible ProV/DODVisitor DC service
$ProVAlerts = $ADDSServerAlerts | ? { ( $_.Name -like "Tangible ProV*" ) }

#$ProVAlerts.Count
$ProVAlerts | select NetBiosComputerName,TimeRaised

$OpenProVAlerts = $ProVAlerts
#$OpenProVAlerts.Count

$ClosedProVAlerts = $ClosedADDSAlert | ? { ( $_.Name -like "Tangible ProV*" ) }
#$ClosedProVAlerts.Count


# DFS-R alerts
$DFSRAlerts = $ADDSServerAlerts | ? { ( $_.Name -like "DFS-R: *" ) }

#$DFSRAlerts.Count
$DFSRAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenDFSRAlerts = $DFSRAlerts
#$OpenDFSRAlerts.Count

$ClosedDFSRAlerts = $ClosedADDSAlert | ? { ( $_.Name -like "DFS-R: *" ) }
#$ClosedDFSRAlerts.Count


# Windows DNS alerts
$DNSAlerts = $ADDSServerAlerts | ? { ( $_.Name -like "Windows DNS *" ) }

# $DNSAlerts.Count
$DNSAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenDNSAlerts = $DNSAlerts
#$OpenDNSAlerts.Count

$ClosedDNSAlerts = $ClosedADDSAlert | ? { ( $_.Name -like "Windows DNS *" ) }
#$ClosedDNSAlerts.Count


# DHCP alerts
$DHCPAlerts = $ADDSServerAlerts | ? { ( $_.Name -like "DHCP*" ) }

#$DHCPAlerts.Count
$DHCPAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenDHCPAlerts = $DHCPAlerts
#$OpenDHCPAlerts.Count

$ClosedDHCPAlerts = $ClosedADDSAlert | ? { ( $_.Name -like "DHCP*" ) }
#$ClosedDHCPAlerts.Count


# SCCM MECM ConfigMgr alerts
$FailedInstallAlerts = $ADDSServerAlerts | ? { ( $_.Name -eq "Failed to install application on client" ) }

#$FailedInstallAlerts.Count
$FailedInstallAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenFailedInstallAlerts = $FailedInstallAlerts
#$OpenFailedInstallAlerts.Count

$ClosedFailedInstallAlerts = $ClosedADDSAlert | ? { ( $_.Name -eq "Failed to install application on client" ) }
#$ClosedFailedInstallAlerts.Count


# High CPU Memory alerts
$HighAlerts = $ADDSServerAlerts | ? { ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Logical disk transfer (reads and writes) latency is too high" ) `
	}

#$HighAlerts.Count
$HighAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenHighAlerts = $HighAlerts
#$OpenHighAlerts.Count

$ClosedHighAlerts = $ClosedADDSAlert | ? { ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Logical disk transfer (reads and writes) latency is too high" ) `
	}
#$ClosedHighAlerts.Count


# Group Policy GPO alerts
$GPOAlerts = $ADDSServerAlerts | ? { ( $_.Name -eq "The Group Policy Update health monitor has failed." ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	}

#$GPOAlerts.Count

$OpenGPOalerts = $GPOAlerts
#$OpenGPOAlerts.Count

$ClosedGPOAlerts = $ClosedADDSAlert | ? { ( $_.Name -eq "The Group Policy Update health monitor has failed." ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	}
#$ClosedGPOAlerts.Count


#
# Remaining alerts - not Proactive
$ADDSRemaining = @()
$ADDSRemaining = $ADDSOpenAlerts | ? { ( $_.Name -notlike "PROACTIVE - Server*" ) }`
	| ? { ( $_.Name -notlike "Logical disk Free space is low*" ) } `
	| ? { ( $_.Name -notlike "Certificate lifespan alert*" ) } `
	| ? { ( $_.Name -notlike "Tangible ProV*" ) } `
	| ? { ( $_.Name -notlike "DFS-R: *" ) } `
	| ? { ( $_.Name -notlike "Windows DNS *" ) } `
	| ? { ( $_.Name -notlike "DHCP*" ) } `
	| ? { ( $_.Name -ne "Failed to Connect to Computer" ) } `
	| ? { ( $_.Name -ne "Failed to install application on client" ) } `
	| ? { ( $_.Name -ne "Health Service Heartbeat Failure" ) } `
	| ? { ( $_.Name -ne "Percentage of Committed Memory in Use is too high" ) } `
	| ? { ( $_.Name -ne "Tangible ProV ProVService Service*" ) } `
	| ? { ( $_.Name -ne "Total CPU Utilization Percentage is too high" ) } `
	| ? { ( $_.Name -ne "VMware (High): Virtual Machine CPU Usage is High" ) } `
	| ? { ( $_.Name -ne "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) } `
	| ? { ( $_.Name -ne "The Group Policy Update health monitor has failed." ) } `
	| ? { ( $_.Name -ne "Group policy processing aborted - cannot determine site" ) } `
	| ? { ( $_.Name -ne "Policy Update Failure" ) `
	}

$ADDSRemaining

$ADDSFormattedRemaining = $ADDSRemaining | select NetbiosComputerName,TimeRaised,Name


# 
# Unhealthy/Maintenance mode agents
# 
  # Gather Details section
  # $Details = get-scomagent | ? { $_.HealthState -ne "Success" } | select DisplayName| out-string
  #$Details

  $Class = (get-scomclass -Name "Microsoft.Windows.Computer" )
  $instance = ( $Class | ? { $_.Name -like "Microsoft.Windows.Computer" }  |Get-SCOMClassInstance )

  $MM = ($Instance | ? { $_.InMaintenanceMode -eq "True" }).DisplayName `
	| ? { ( $_.DisplayName -like "DC0*" ) `
	-OR ( $_.DisplayName -like "*W4NHAAH7*" ) `
	-OR ( $_.DisplayName -like "*W054AAA0*" ) `
	-OR ( $_.DisplayName -like "*W054AAA1*" ) `
	-OR ( $_.DisplayName -like "*W054AAA4*" ) `
	-OR ( $_.DisplayName -like "*W054AAA7*" ) `
	-OR ( $_.DisplayName -like "*W054AAC1*" ) `
	-OR ( $_.DisplayName -like "*W054AADH*" ) `
	-OR ( $_.DisplayName -like "*W054AAH0*" ) `
	-OR ( $_.DisplayName -like "*W054AAH1*" ) `
	-OR ( $_.DisplayName -like "*W054AAH2*" ) `
	-OR ( $_.DisplayName -like "*W054AAH3*" ) `
	-OR ( $_.DisplayName -like "*W054AAH4*" ) `
	-OR ( $_.DisplayName -like "*W054AAH6*" ) `
	-OR ( $_.DisplayName -like "*W054AAH8*" ) `
	-OR ( $_.DisplayName -like "*W054AAK9*" ) `
	}
	write-host "MM Maintenance mode Agents `n" ; $Unhealthy.InputObject
    $MaintM = $MM | sort | out-string

#   $UnHealthyAgents = get-scomagent
$UnHealthyAgents = ( get-scomagent | ? { $_.HealthState -ne "Success" }).DisplayName `
	| ? { ( $_.DisplayName -like "DC0*" ) `
	-OR ( $_.DisplayName -like "*W4NHAAH7*" ) `
	-OR ( $_.DisplayName -like "*W054AAA0*" ) `
	-OR ( $_.DisplayName -like "*W054AAA1*" ) `
	-OR ( $_.DisplayName -like "*W054AAA4*" ) `
	-OR ( $_.DisplayName -like "*W054AAA7*" ) `
	-OR ( $_.DisplayName -like "*W054AAC1*" ) `
	-OR ( $_.DisplayName -like "*W054AADH*" ) `
	-OR ( $_.DisplayName -like "*W054AAH0*" ) `
	-OR ( $_.DisplayName -like "*W054AAH1*" ) `
	-OR ( $_.DisplayName -like "*W054AAH2*" ) `
	-OR ( $_.DisplayName -like "*W054AAH3*" ) `
	-OR ( $_.DisplayName -like "*W054AAH4*" ) `
	-OR ( $_.DisplayName -like "*W054AAH6*" ) `
	-OR ( $_.DisplayName -like "*W054AAH8*" ) `
	-OR ( $_.DisplayName -like "*W054AAK9*" ) `
	}
	# | ? { ( $_.HealthState -eq "Uninitialized" ) }



if ( ( $UnhealthyAgents.count -gt 0 ) -AND ( $MM.Count -gt 0 ) )
	{
	$CompareMM = compare-object -ReferenceObject $MM -DifferenceObject $UnhealthyAgents
	}
if (  $MM.Count -gt 0 )
	{
	$CompareMM = $MM
	}


  #foreach ( $server in $UnHealthyAgents )
	#{
	#if ( ! $($MaintM | select-string $server) -eq $True )
		#{ 
		#write-host $server "is in Maintenance"
		#$Unhealthy += "$server"
		#}
	#}

  #$Unhealthy
  #$Details = $Unhealthy.InputObject

 
# Check for repeatedly down agents

$DownAgentsAlerts = $ADDSOpenAlerts | where { ($_.Name -eq "Health Service Heartbeat Failure") `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	}


$DownAgentsAlerts.Count
#$DownAgentsAlerts.MonitoringObjectDisplayName | sort -uniq

if ( $DownAgentsAlerts.Count -gt 0 )
	{
	# Open alerts since last report
	$DownAgentsOpenTime = $DownAgentsAlerts | where { $_.TimeRaised -gt $Time }

	# Closed alerts since last report
	$DownAgentsClosedTime = $ClosedADDSAlert | where { ($_.Name -eq "Health Service Heartbeat Failure") `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	} | where { $_.TimeRaised -gt $Time }
	#
	$DownAgentsOpenTime.MonitoringObjectDisplayName | sort -uniq
	$DownAgentsClosedTime.MonitoringObjectDisplayName | sort -uniq
	}


#Get SCOM agents in grey state
# From blog 
# https://www.powershellbros.com/get-list-unhealthy-scom-agents-grey-state-using-powershell/
#
$Agent = Get-SCOMClass -Name Microsoft.Windows.Computer
$Objects = Get-SCOMMonitoringObject -class:$Agent | Where-Object {$_.IsAvailable -eq $false}
$FilteredObjects = $Objects | where { $_.InMaintenanceMode -ne $True } `
	| where { ( $_.DisplayName -like "DC0*" ) `
	-OR ( $_.DisplayName -like "*W4NHAAH7*" ) `
	-OR ( $_.DisplayName -like "*W054AAA0*" ) `
	-OR ( $_.DisplayName -like "*W054AAA1*" ) `
	-OR ( $_.DisplayName -like "*W054AAA4*" ) `
	-OR ( $_.DisplayName -like "*W054AAA7*" ) `
	-OR ( $_.DisplayName -like "*W054AAC1*" ) `
	-OR ( $_.DisplayName -like "*W054AADH*" ) `
	-OR ( $_.DisplayName -like "*W054AAH0*" ) `
	-OR ( $_.DisplayName -like "*W054AAH1*" ) `
	-OR ( $_.DisplayName -like "*W054AAH2*" ) `
	-OR ( $_.DisplayName -like "*W054AAH3*" ) `
	-OR ( $_.DisplayName -like "*W054AAH4*" ) `
	-OR ( $_.DisplayName -like "*W054AAH6*" ) `
	-OR ( $_.DisplayName -like "*W054AAH8*" ) `
	-OR ( $_.DisplayName -like "*W054AAK9*" ) `
	}

$Monitored = $FilteredObjects | where { $_.AvailabilityLastModified -gt $Time } | sort -property DisplayName -uniq
# $Monitored.DisplayName

# Display list of agents/servers and when modified
$FilterMonitored = $Monitored | select AvailabilityLastModified,DisplayName


$NotMonitored = $FilteredObjects | where { $_.AvailabilityLastModified -lt $Time } | sort -property DisplayName -uniq


$RepeatDownAgents = @()
$CurrentDownAgents = @()

# Compare repeated agent down
if ( $DownAgentsOpenTime.Count -eq 0 )
	{
	$RepeatDownAgents += ""
	$RepeatDownAgents += "ZERO Repeated down agents as of report run"
	$RepeatDownAgents += ""
	}
	
if ( $DownAgentsOpenTime.Count -gt 0 )
	{
	# Display list of agents/servers and when modified
	# $FilterMonitored
	If ( $Monitored.Count -gt 0 )
		{
		foreach ( $server in $Monitored.DisplayName)
			{
			$CurrentDownCompare = $DownAgentsOpenTime.MonitoringObjectDisplayName | select-string -simplematch $server
			if ( $CurrentDownCompare.Count -gt 0 )
				{
				$CurrentDownAgents += $server
				}
			$RepeatCount = $NotMonitored.DisplayName | select-string -simplematch $server
			$RepeatCount
			if ( $RepeatCount.Count -gt 0 )
				{
				$RepeatDownAgents += $server
				}
			}
		}
	}

# Debug
#$RepeatDownAgents
#  $RepeatDownAgents.Count
#$CurrentDownAgents
#  $CurrentDownAgents.Count


$UniqOldDownAgentsArray = @()

# Remove whitespace when output contains ZERO
if ( $($($RepeatDownAgents | select-string -simplematch "ZERO" ).Count) -gt 0 )
	{
	$UniqOldDownAgentsArray += "ZERO Repeatcount check NOT monitored servers as of report run"
	}

#if ( $RepeatDownAgents.Count -gt 1 )
if ( $($($RepeatDownAgents | select-string -NOTmatch "ZERO" ).Count) -gt 0 )
	{
	$RepeatDownAgents = $RepeatDownAgents | ? { $_ -and $_.Trim() }
	
	$RepeatDownServers = $RepeatDownAgents  | select-string -NOTmatch "ZERO"
	if ( $RepeatDownServers.Count -gt 0 )
		{
		foreach ( $server in $RepeatDownServers )
			{
			$TestConnectivity = test-netconnection -ComputerName $server -port 5723
			if ( $TestConnectivity.TcpTestSucceeded -eq $False )
				{
				$UniqOldDownAgentsArray += "$server fails TCP5723 connectivity"
				$UniqOldDownAgentsArray += ""
				$UniqOldDownAgentsArray += "Verify Microsoft Monitoring Agent is installed, and healthservice running via 'get-service healthservice'"
				$UniqOldDownAgentsArray += ""
				}
			}
		}
	}

	#$UniqOldDownAgentsArray = $UniqOldDownAgentsArray | ? { $_ -and $_.Trim() }
	$UniqOldDownAgentsArray
	$UniqOldDownAgentsArray = $UniqOldDownAgentsArray | out-string


	#
	#if ( $TestConnectivity.PingSucceeded -eq "False" )
	#	{
	#	$UniqOldDownAgentsArray += "SCOM cannot ping $server, contact network team to resolve firewall issue"
	#	}
	#}



# Analyze down agents
if ( $DownAgents.Count -eq 0 )
	{
	$Compare = $MM.Count + $CompareMM.Count
    $CompareDown = "ZERO NOT monitored servers as of report run"
	}

if ( $DownAgents.Count -gt 0 )
	{
    if ( $UnHealthyAgents.count -gt 0 )
		{
		$CompareDown = compare-object -ReferenceObject $DownAgents -DifferenceObject $UnhealthyAgents
		# Format output of DownAgents
		$Down = $DownAgents | select MonitoringObjectDisplayName,TimeRaised,Name | out-string
		$Down
		}
    if ( $UnHealthyAgents.count -eq 0 )
		{
		$Down = $DownAgents | select MonitoringObjectDisplayName | out-string
		$Down
		}
	}



# Compare Unhealthy agents
$Unhealthy = @()
	
if ( $UnHealthyAgents.Count -eq 0 )
	{
	#$Unhealthy += ""
	$Unhealthy += "ZERO NOT healthy agents as of report run"
	}
	
if ( $UnHealthyAgents.Count -gt 0 )
	{
	#$Unhealthy += ""
	$Unhealthy += $UnHealthyAgents.DisplayName | sort -uniq | out-string
	#$Unhealthy += ""
	}
	
  $Test = $DownAgents.Count +   $UnHealthyAgents.Count
  $Test


# Update to consolidate all the methods into a unique list
#===========================================================
$TotalAgentIssues = @()

if ( $Down -gt 0 )
	{
	$TotalAgentIssues += $Down
	$TotalAgentIssues += ""
	}
if ( $RepeatDownAgents.Count -gt 0 )
	{
	$TotalAgentIssues += $RepeatDownAgents
	$TotalAgentIssues += ""
	}
if ( $Unhealthy.Count -gt 0 )
	{
	$TotalAgentIssues += $Unhealthy
	$TotalAgentIssues += ""
	}
if ( $Monitored.Count -gt 0 )
	{
	$TotalAgentIssues += $Monitored.DisplayName
	$TotalAgentIssues += ""
	}
if ( $NotMonitored.Count -gt 0 )
	{
	$TotalAgentIssues += $NotMonitored.DisplayName
	$TotalAgentIssues += ""
	}

#
#	$TotalAgentIssues = $TotalAgentIssues | ? { $_ -and $_.Trim() }
#	$TotalAgentIssues += ""

$TotalAgentsFiltered = $TotalAgentIssues | ? { $_ -and $_.Trim() } | select-string -NOTmatch "ZERO"

#===============================================
#
# Logical Disk free space alerts
#===============================================

$LDSTest = $ADDSServerAlerts | ? { $_.Name -eq "Logical disk Free space is low" }

if ( $LDSTest.Count -gt 0 )
	{
	$LDSTest

	# Gather details
	$LDSSummary = $LDSTest |select NetbiosComputerName,MonitoringObjectName,Parameters | out-string
	# Gather Details section
	$LDSDetails = $LDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string

	$LDSSummary
	$LDSDetails
  
	$OpenLDSTest = $LDSTest | ? { $_.ResolutionState -ne "255" }
	$OpenLDSTest.Count

	if ( $OpenLDSTest.Count -gt 0 )
		{
		# Summary
		$LDSOpenSummary = $LDSTest | select NetbiosComputerName,MonitoringObjectName,Parameters | out-string
		# Gather Details
		$LDSOpenDetails = $LDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string
		}

	$ClosedLDSTest = $ClosedADDSAlert | ? { $_.Name -eq "Logical disk Free space is low" }
	$ClosedLDSTest.Count

	if ( $ClosedLDSTest.Count -gt 0 )
		{
		# Summary
		$LDSClosedSummary = $ClosedLDSTest | select NetbiosComputerName,MonitoringObjectName,Parameters | out-string
		# Gather Details section
		$LDSClosedDetails = $ClosedLDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string
		}
	}


#===============================================
# Expiring certificates
# Certificates about to expire/expired
#===============================================

$Class = (get-scomclass -DisplayName "Certificate" )
$instance = ( $Class |Get-SCOMClassInstance )
$ADDSPKIexpired = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	# PKI certs can have Certstore, but it's not always searchable/display capable
	# } | ? { $_.CertStore -like "Intermediate Certification*" `
	# PKI certs don't use NetbiosComputerName, and PrincipalName does not output
	} | ? { ( $_.Path -like "DC0*" ) `
	-OR ( $_.Path -like "*W4NHAAH7*" ) `
	-OR ( $_.Path -like "*W054AAA0*" ) `
	-OR ( $_.Path -like "*W054AAA1*" ) `
	-OR ( $_.Path -like "*W054AAA4*" ) `
	-OR ( $_.Path -like "*W054AAA7*" ) `
	-OR ( $_.Path -like "*W054AAC1*" ) `
	-OR ( $_.Path -like "*W054AADH*" ) `
	-OR ( $_.Path -like "*W054AAH0*" ) `
	-OR ( $_.Path -like "*W054AAH1*" ) `
	-OR ( $_.Path -like "*W054AAH2*" ) `
	-OR ( $_.Path -like "*W054AAH3*" ) `
	-OR ( $_.Path -like "*W054AAH4*" ) `
	-OR ( $_.Path -like "*W054AAH6*" ) `
	-OR ( $_.Path -like "*W054AAH8*" ) `
	-OR ( $_.Path -like "*W054AAK9*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName

$ADDSPKIexpired.count

# Intermediate Cert Check
	# PKI certs can have Certstore, but it's not always searchable/display capable
	#} | ? { $_.CertStore -like "Intermediate Certification*" `

$ADDSIntermediate = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { $_.CertStore -like "Intermediate Certification*" }
	# $ADDSIntermediate.Count


$ADDSRootCerts = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { $_.CertStore -like "Root" }
	# $ADDSRootCerts.Count



# Build report
$ADDSTeamReport = @()


# Check for alerts 
if ( $ADDSServerAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for ADDS Team Daily report for ($date)"
	$ADDSTeamReport += "ZERO alerts for ADDS Team Daily report for ($date)"
	$ADDSTeamReport += ""
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $ADDSServerAlerts.Count -gt 0 )
	{
	#
	# Create table output

	#
	# Show ADDS alerts by Time Raised,NetBiosComputerName,Message
	#
	$ADDSTeamReport += $Message
	$ADDSTeamReport += ""
	$ADDSTeamReport += "# ADDS Team Daily report for $($date)"
	$ADDSTeamReport += "#"
	$ADDSTeamReport += "# Alerts since last run = $($ADDSAlertsSinceReport.Count)"
	$ADDSTeamReport += "#"
	$ADDSTeamReport += "# Total OPEN alerts"
	$ADDSTeamReport += "#========================================================"
	$ADDSTeamReport += "# AD Team alerts = $($ADDSOpenAlerts.count)"
	$ADDSTeamReport += ""
	$ADDSTeamReport += "# Server performance alerts = $($OpenHighAlerts.Count)"
	$ADDSTeamReport += "# Logical Disk full alerts = $($OpenLDSTest.Count)"
	$ADDSTeamReport += ""
	$ADDSTeamReport += "# PKI expired certificate alerts = $($ADDSPKIexpired.Count)"
	$ADDSTeamReport += "# PKI Intermediate certificate alerts = $($ADDSIntermediate.Count)"
	$ADDSTeamReport += "# PKI Root certificate alerts = $($ADDSRootCerts.Count)"
	$ADDSTeamReport += ""
 	$ADDSTeamReport += "# Failed to install MECM application packages = $($OpenFailedInstallAlerts.Count)"
	if ( $OpenProVAlerts.Count -gt 0 )
		{
		$ADDSTeamReport += "# Tangible ProV alerts = $($OpenProVAlerts.Count)"
		}
	$ADDSTeamReport += "# DFS-R alerts = $($OpenDFSRAlerts.Count)"
 	$ADDSTeamReport += "# DNS alerts = $($OpenDNSAlerts.Count)"
 	$ADDSTeamReport += "# DHCP alerts = $($OpenDHCPAlerts.Count)"
 	$ADDSTeamReport += "# Group Policy alerts = $($OpenGPOAlerts.Count)"
	$ADDSTeamReport += "#========================================================"
 	$ADDSTeamReport += "# Servers Pending Restart = $($OpenPendingRestart.Count)"
 	$ADDSTeamReport += "# Servers NOT rebooted= $($OpenNotRebooted.Count)"
 	$ADDSTeamReport += "# Servers NOT patched = $($OpenNotPatched.Count)"
 	$ADDSTeamReport += "# Group Policy alerts = $($OpenGPOAlerts.Count)"
	$ADDSTeamReport += ""
 	$ADDSTeamReport += "# Total remaining alerts = $($ADDSRemaining.Count)"
	$ADDSTeamReport += "#========================================================"
	$ADDSTeamReport += ""
	$ADDSTeamReport += "# Monitoring Health details"
	$ADDSTeamReport += "#=========================="


	if ( $TotalAgentsFiltered.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO unmonitored servers as of report run"
		$ADDSTeamReport += ""
		}

	if ( $TotalAgentsFiltered.Count -gt 0 )
		{
		$ADDSTeamReport += "# Total Unhealthy, NOT monitored servers"
		$ADDSTeamReport += "#======================================="
		$ADDSTeamReport += $TotalAgentsFiltered | sort -uniq | out-string
		$ADDSTeamReport += "#======================================="
		$ADDSTeamReport += ""
		}


		# Add logic for agents monitored/down/maintenance mode
	if ( $Test -eq 0)
		{
		$ADDSTeamReport += "ZERO MECM servers NOT monitored for ($date)."
		$ADDSTeamReport += ""
		}
	
	if ( $Test -gt 0)
		{
		$ADDSTeamReport += "# NOT monitored servers for ($date)."
		$ADDSTeamReport += "#================================================"
		$ADDSTeamReport += $Down
		$ADDSTeamReport += ""

		if ( $MM.Count -eq 0)
			{
			$ADDSTeamReport += "ZERO MECM servers in maintenance mode for ($date)."
			$ADDSTeamReport += ""
			}

		if ( $MM.Count -gt 0)
			{
			$ADDSTeamReport += ""
			$ADDSTeamReport += "# Servers in Maintenance Mode MM"
			$ADDSTeamReport += "#==============================="
			$ADDSTeamReport += $MaintM
			$ADDSTeamReport += ""
			$ADDSTeamReport += ""
			}
		}


	if ( $HighAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO Server performance issues for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $HighAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# Server performance alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenHighAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}


	if ( $OpenGPOAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO Group Policy Object issues for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenGPOAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# Group Policy Object (GPO) alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenGPOAlerts | select TimeRaised,NetbiosComputername | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

 	if ( $OpenLDSTest.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS Logical Disk free space alerts for ($date)."
		$ADDSTeamReport += ""
		}
		
	if ( $OpenLDSTest.Count -gt 0 )
		{
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# Summary of Daily Logical Disk free space alerts for ($date)"
		$ADDSTeamReport += "#============================================================"
		$ADDSTeamReport += "#"
		$ADDSTeamReport += "# Logical Disk Free Space alerts"
		$ADDSTeamReport += "#=============================="
		$ADDSTeamReport += $LDSOpenSummary
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# Alert details"
		$ADDSTeamReport += "#=============================="
		$ADDSTeamReport += $LDSOpenDetails
		$ADDSTeamReport += ""
		}

	if ( $ADDSPKIexpired.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS PKI Certificates about to expire for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $ADDSPKIexpired.Count -gt 0 )
		{
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# Certificates about to expire/expired"
		$ADDSTeamReport += "#============================================================"
		$ADDSTeamReport += $ADDSPKIexpired | ft Path,Values -auto -wrap | out-string
		$ADDSTeamReport += ""
		}

	if ( $ADDSIntermediate.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS PKI Intermediate Certificates alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $ADDSIntermediate.Count -gt 0 )
		{
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# ADDS Intermediate Certificate alerts = $($ADDSIntermediate.Count)"
		$ADDSTeamReport += "#============================================================"
		$ADDSTeamReport += $ADDSIntermediate | ft Path,Values -auto -wrap | out-string
		$ADDSTeamReport += ""
		$ADDSTeamReport += "***Execute MANUAL task to disable certs!"
		$ADDSTeamReport += ""
		}

	if ( $ADDSRootCerts.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS PKI Root Certificates alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $ADDSRootCerts.Count -gt 0 )
		{
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# ADDS Root Certificate alerts = $($SharePointIntermediate.Count)"
		$ADDSTeamReport += "#============================================================"
		$ADDSTeamReport += $ADDSRootCerts | ft Path,Values -auto -wrap | out-string
		$ADDSTeamReport += ""
		$ADDSTeamReport += "***Execute MANUAL task to disable certs!"
		$ADDSTeamReport += ""
		}

	if ( $OpenProVAlerts.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO Tangible ProV alerts for ($date)."
		$ADDSTeamReport += ""
		}
		
	if ( $OpenProVAlerts.Count -gt 0 )
		{
		$ADDSTeamReport += "# Tangible ProV/DODVisitor Service alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenProVAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}


	if ( $OpenDFSRAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO DFS-R alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenDFSRAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# DFS-R alert detail"
		$ADDSTeamReport += "#============================================="
	if ( $OpenDFSRAlerts.count -lt 10 )
		{
		$ADDSTeamReport += $OpenDFSRAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += ""
		}
	if ( $OpenDFSRAlerts.count -ge 10 )
		{
		$ADDSTeamReport += "The number of Windows DFS-R alerts for AD owned servers is greater than 10"
		}
		#$ADDSTeamReport += $OpenDFSRAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenDNSAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO DNS alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenDNSAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# DNS alert detail"
		$ADDSTeamReport += "#============================================="
	if ( $OpenDNSAlerts.count -lt 10 )
		{
		$ADDSTeamReport +=  $DNSAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += ""
		}
	if ( $OpenDNSAlerts.count -ge 10 )
		{
		$ADDSTeamReport += "The number of Windows DNS alerts for AD owned servers is greater than 10"
		}
		#$ADDSTeamReport += $OpenDNSAlerts  | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenDHCPAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO DHCP alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenDHCPAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# DHCP alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenDHCPAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenFailedInstallAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO MECM install failures for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenFailedInstallAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# MECM install failure alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenFailedInstallAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}


	if ( $ADDSRemaining.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS remaining Operating System and issues for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $ADDSRemaining.count -gt 0 )
		{
		$ADDSTeamReport += "# Other ADDS application OR Operating System issues "
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $ADDSRemaining | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenPendingRestart.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS servers pending restart for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenPendingRestart.count -gt 0 )
		{
		$ADDSTeamReport += "# ADDS servers pending reboot for patches"
		$ADDSTeamReport += "#============================================="
	if ( $OpenPendingRestart.count -lt 10 )
		{
		$ADDSTeamReport += $OpenPendingRestart | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += ""
		}
	if ( $OpenPendingRestart.count -ge 10 )
		{
		$ADDSTeamReport += "The number of AD owned servers pending reboot is greater than 10"
		}
		#$ADDSTeamReport += $OpenPendingRestart | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenNotRebooted.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS servers NOT rebooted in past 35 days as of ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenNotRebooted.count -gt 0 )
		{
		$ADDSTeamReport += "# ADDS servers NOT rebooted (at least 35 days pass before alert)"
		$ADDSTeamReport += "#============================================="

	if ( $OpenNotRebooted.count -lt 10 )
		{
		$ADDSTeamReport += $OpenNotRebooted  | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += ""
		}
	if ( $OpenNotRebooted.count -ge 10 )
		{
		$ADDSTeamReport += "The number of AD owned servers NOT rebooted in past 35 days is greater than 10"
		}
		#$ADDSTeamReport += $OpenNotRebooted | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenNotPatched.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS servers NOT patched in past 35 days as of ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenNotPatched.count -gt 0 )
		{
		$ADDSTeamReport += "# ADDS servers not patched (at least 35 days pass before alert)"
		$ADDSTeamReport += "#============================================="
	if ( $OpenNotPatched.count -lt 10 )
		{
		$ADDSTeamReport += $OpenNotPatched | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += ""
		}
	if ( $OpenNotPatched.count -ge 10 )
		{
		$ADDSTeamReport += "The number of AD owned servers NOT rebooted in past 35 days is greater than 10"
		}
		#$ADDSTeamReport += $OpenNotPatched | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += "#========================"
		}

	$ADDSTeamReport += ""
	}

$ADDSTeamReport


$ADDSTeamReport = $ADDSTeamReport | out-string

#============================================================

  $Result = "GOOD"
  $Message = "AD Team Daily report for ($date)"

  $momapi.LogScriptEvent($ScriptName,$EventID,0,"$ADDSTeamReport")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$ADDSTeamReport)

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive Microsoft Windows Server Addendum AD 2016 Reports Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.DailyTasks.ADDSAlerts.GroupPolicyReport.Script.DataSource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>05:11</Start>
                        <End>05:31</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.DailyTasks.ADDSAlerts.GroupPolicyReport.Script.Alert.DataSource.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather ADDS GroupPolicyReport alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.ADDSAlerts.GroupPolicyReport.Script.Alert.DataSource.v1047.ps1"
$EventID = "552"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts GroupPolicy Report Script is starting.  Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-7)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive DailyTasks ADDS Group Policy report automation for ($date).")
$Message = "Proactive DailyTasks ADDS Group Policy report automation for ($date)."


# Gather AD alerts
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
# Proactive DailyTasks ADDSAlerts 2016+ GroupPolicyFailed Rule Alert
# Proactive DailyTasks ADDSAlerts 2016+ GroupPolicyObjectsFiltered Rule Alert
# Proactive DailyTasks ADDSAlerts 2016+ DC GroupPolicyFailed Rule Alert
# Proactive DailyTasks ADDSAlerts 2016+ DC GroupPolicyObjectsFiltered Rule Alert
# Group Policy Client service not running
# Microsoft Windows Server 2016+ GroupPolicyClient gpsvc Service Monitor
# $GPOAlerts = $(get-scomalert -name "The Group Policy Update health monitor has failed." | ? { $_.TimeRaised -gt $Time } ).Description

$SCOMCoreReportAlerts = @(Get-SCOMAlert -name "Proactive DailyTasks ADDSAlerts 2016*GroupPolicy* Rule Alert" -ResolutionState (0..254) `
	; get-scomalert -name "The Group Policy Update health monitor has failed." -ResolutionState (0..254) `
	; get-scomalert -name "Group Policy Client service not running" -ResolutionState (0..254) `
	; get-scomalert -name "Group Policy Client service not running gpsvc Addendum Service Monitor" -ResolutionState (0..254) )
$SCOMCoreReportAlerts.Count

# Open/Closed breakout
$OpenGroupPolicyAlerts = $SCOMCoreReportAlerts
$OpenGroupPolicyAlerts.Count
$ClosedGroupPolicyAlerts = @(Get-SCOMAlert -name "Proactive DailyTasks ADDSAlerts 2016*GroupPolicy* Rule Alert" -ResolutionState 255 `
	; get-scomalert -name "The Group Policy Update health monitor has failed." -ResolutionState 255 `
	; get-scomalert -name "Group Policy Client service not running" -ResolutionState 255 `
	; get-scomalert -name "Group Policy Client service not running gpsvc Addendum Service Monitor" -ResolutionState 255 )
$ClosedGroupPolicyAlerts.Count


# Build report
#========================================================== 

if ( $SCOMCoreReportAlerts.Count -eq 0 )
	{
	$DFSAMessage += "ZERO alerts for ADDS Group Policy report workflow for ($date)"
	$Message = "ZERO alerts for ADDS Group Policy report workflow for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	#
	# Build report
	$GroupPolicyReportMessage = @()
	$GroupPolicyReportMessage += ""
	$GroupPolicyReportMessage += $Message
	$GroupPolicyReportMessage += ""
	$GroupPolicyReportMessage += "# ADDS Group Policy alerts auto-closed"
	$GroupPolicyReportMessage += "#============================================================"
	$GroupPolicyReportMessage += "# Total Group Policy alerts = $($SCOMCoreReportAlerts.Count)"
	$GroupPolicyReportMessage += "#"
	$GroupPolicyReportMessage += "# Open alerts = $($OpenGroupPolicyAlerts.Count)"
	$GroupPolicyReportMessage += "# Closed alerts = $($ClosedGroupPolicyAlerts.Count)"
	$GroupPolicyReportMessage += "#"
	$GroupPolicyReportMessage += "# Group Policy event details"
	$GroupPolicyReportMessage += "#========================================="
	$GroupPolicyReportMessage += $SCOMCoreReportAlerts | where { $_.Name -like "*GroupPolicy*"} | select TimeRaised,MonitoringObjectDisplayName,NetbiosComputername,Description
	$GroupPolicyReportMessage += "#========================================="
	$GroupPolicyReportMessage += ""
	$GroupPolicyReportMessage += "# Group Policy updates and client gpsvc service NOT running details"
	$GroupPolicyReportMessage += "#========================================="
	$GroupPolicyReportMessage += $SCOMCoreReportAlerts | where { $_.Name -like "*Group Policy*"} | select TimeRaised,MonitoringObjectDisplayName,NetbiosComputername,Description
	$GroupPolicyReportMessage += "#========================================="
	}

$GroupPolicyReportMessage

$GroupPolicyReportMessage = $GroupPolicyReportMessage | out-string


# Log data event before resetting monitors
#============================================================
  $Result = "GOOD"

  $momapi.LogScriptEvent($ScriptName,$EventID,0,"# Proactive DailyTasks ADDS Group Policy report automation automation for ($date). `n `n$GroupPolicyReportMessage")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$GroupPolicyReportMessage)

# Return all bags
$bag


# Debug Write event for rule closure
#=================================================================================
$SCOMCoreRulesToClear = $SCOMCoreRuleAlerts | where { ( $_.TimeAdded -lt $Age ) }
# Convert Age back to days for alert properties logging
$Days = ((Get-date) - $Age).Days
if ( $SCOMCoreRulesToClear.Count -gt 0 )
	{
	$SCOMCoreRulesToClear | Resolve-SCOMAlert -Comment "Closing $Days day old alerts after report alert generated - ADDS Addendum Group Policy alert closure automation DS"
	}

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS Group Policy report automation rule reset completed for ($date)")


#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts GroupPolicy Report Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.DataSource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>05:52</Start>
                        <End>06:12</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.DailyTasks.ADDS.ComponentAlert.Script.DataSource.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather ADDS Component alert consolidation
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.ADDS.ComponentAlert.Script.DataSource.v1047.ps1"
$EventID = "550"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS ComponentAlert DS Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive DailyTasks ADDS ComponentAlert automation for ($date).")
$DSMessage = "Proactive DailyTasks ADDS ComponentAlert automation for ($date)."


# Gather AD and OS management packs and put into array
#=================================================================================
$ADDSPacks = get-scommanagementpack -DisplayName "Active Directory Domain Services for Microsoft Windows Server 201**Monitoring)"

# Verify if other packs are installed to add to component monitor array

if ( $ADDSPacks.Count -gt 0 )
	{
	$ADMgmtPackArray = @()

	$ADMgmtPackArray += "Active Directory Domain Services for Microsoft Windows Server 2016 and above (Monitoring)"
	$ADMgmtPackArray += "Active Directory Domain Services for Microsoft Windows Server 2012 R2 (Monitoring)"
	$ADMgmtPackArray += "Active Directory Domain Services for Microsoft Windows Server 2012 (Monitoring)"
	$ADMgmtPackArray += "Active Directory Server 2008 and above (Monitoring)"

	$ADMgmtPackArray += "File Services Management Pack for Windows Server 2016 and above"
	$ADMgmtPackArray += "Microsoft Windows Server 2016 and 1709+ DNS Monitoring"
	$ADMgmtPackArray += "Microsoft Windows Server DNS Monitoring"

	$ADMgmtPackArray += "Windows Server 2016+ Active Directory Certificate Services Monitoring"
	$ADMgmtPackArray += "Microsoft Windows Server Active Directory Certificate Services 2012 R2 Monitoring"
	$ADMgmtPackArray += "Microsoft Windows Server Active Directory Certificate Services 2012 Monitoring"

	$ADMgmtPackArray += "Windows Server 2016 and above Operating Systems (Monitoring)"
	$ADMgmtPackArray += "Windows Server 2012 R2 Operating System (Monitoring)"
	$ADMgmtPackArray += "Windows Server 2012 Operating System (Monitoring)"

	$ADMgmtPackArray += "Microsoft Windows Server DHCP 2016 and above"

	$ADMgmtPackArray += "System Center Core Monitoring"
	}


## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
#=================================================================================
$SCOMCoreMP = @()
$SCOMCoreRules = @()
$SCOMCoreMonitors = @()

foreach ( $ADpacks in $ADMgmtPackArray )
	{
	$SCOMCoreMP += Get-SCOMManagementPack -DisplayName $ADpacks

	$SCOMCoreRules += $SCOMCoreMP.GetRules()
	$SCOMCoreMonitors += $SCOMCoreMP.GetMonitors()
	#$SCOMCoreMonitors.Count
	}

	$SCOMCoreMonitors.Count
	$SCOMCoreRules.Count

# Remove duplicates across pack families
$UniqSCOMCoreRules = $SCOMCoreRules | sort -property DisplayName -uniq
$UniqSCOMCoreMonitors =  $SCOMCoreMonitors | sort -property DisplayName -uniq

# Debug
$UniqSCOMCoreRules.Count
$UniqSCOMCoreMonitors.Count

# Tally up the alerts
#=================================================================================
$SCOMCoreReportAlerts = @(Get-SCOMAlert -ResolutionState (0..254) | ? { ( $_.Name -in $UniqSCOMCoreRules.DisplayName ) -OR ( $_.Name -in $UniqSCOMCoreMonitors.DisplayName ) } )
$SCOMCoreMonitortAlerts = @($SCOMCoreReportAlerts | ? { ( $_.Name -in $UniqSCOMCoreMonitors.DisplayName ) } )
$SCOMCoreRuleAlerts = @($SCOMCoreReportAlerts | ? { ( $_.Name -in $UniqSCOMCoreRules.DisplayName ) } )

# Debug
$SCOMCoreReportAlerts.Count
$SCOMCoreMonitortAlerts.Count
$SCOMCoreRuleAlerts.Count

# Call it lack of trust, but rules/monitors name,displayName other than DNS do NOT contain alert names
$ADDSAlerts = @()

$ADDSAlerts = get-scomalert -ResolutionState (0..254) | ? { ( $_.Name -like "AD *" ) `
	-OR ( $_.Name -eq "DCLocator test failed to locate a domain controller." ) `
	-OR ( $_.Name -like "Group Policy *" ) `
	-OR ( $_.Name -like "Logical disk transfer *" ) `
	-OR ( $_.Name -like "Proactive Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "Replication Partner Count health monitor has failed." ) `
	-OR ( $_.Name -like "The*Availability health monitor has failed." ) `
	-OR ( $_.Name -eq "The Time Skew monitor has failed." ) `
	-OR ( $_.Name -like "Windows DNS *" ) `
	-OR ( $_.Name -eq "A dll cannot be loaded because the software was incorrectly installed" ) `
	-OR ( $_.Name -eq "A RSoP (Resultant Set of Policies) error occurred" ) `
	-OR ( $_.Name -eq "A user from a different forest logged onto this machine. Group policy processing has been effected." ) `
	-OR ( $_.Name -eq "Account creation will fail on this domain controller until the account identifier pool is obtained" ) `
	-OR ( $_.Name -eq "Account Name Not Unique" ) `
	-OR ( $_.Name -eq "An account name collision occurred - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "An attempt to check whether group caching is enabled has failed" ) `
	-OR ( $_.Name -eq "An attempt to set the time was aborted due to the offset being too large" ) `
	-OR ( $_.Name -eq "An attempt to update user credentials failed" ) `
	-OR ( $_.Name -eq "Change Password on KRBTGT Account Failed" ) `
	-OR ( $_.Name -eq "Corrupt Credentials" ) `
	-OR ( $_.Name -eq "DNS registrations of essential Domain controller records is failing" ) `
	-OR ( $_.Name -eq "Domain Operation Mode has been changed to Native Mode" ) `
	-OR ( $_.Name -eq "Duplicate User Principal Names have been detected" ) `
	-OR ( $_.Name -like "Failed to ping or bind*" ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Invalid Forwarded AS Request" ) `
	-OR ( $_.Name -eq "Invalid Policy Data" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Active Directory GPO lookup failure" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Security Configuration Engine error occurred" ) `
	-OR ( $_.Name -eq "Memory Allocation Error - the system may be overloaded" ) `
	-OR ( $_.Name -eq "No input provider to sync time" ) `
	-OR ( $_.Name -eq "PAC Verification Failure" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*" ) `
	-OR ( $_.Name -eq "The account identifier pool for this domain controller cannot be updated" ) `
	-OR ( $_.Name -eq "The computer name cannot be mapped to an object in Active Directory - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "The DC was unable to obtain the next account-identifier" ) `
	-OR ( $_.Name -eq "The domain controller failed to obtain a new account identifier pool" ) `
	-OR ( $_.Name -like "The domain controller has been *" ) `
	-OR ( $_.Name -eq "The group caching option has now been properly updated" ) `
	-OR ( $_.Name -eq "The machine account cannot be found" ) `
	-OR ( $_.Name -eq "The number of Group Policies has exceeded the maximum limit" ) `
	-OR ( $_.Name -eq "The registry policy file could not be accessed during application of machine policy" ) `
	-OR ( $_.Name -eq "The system clock has not been synchronized for some time" ) `
	-OR ( $_.Name -eq "This domain controller will not start up because its machine account has been deleted" ) `
	-OR ( $_.Name -eq "Trusted Domain List Update Failure" ) `
	-OR ( $_.Name -eq "Unexpected SAM Failure" ) `
	-OR ( $_.Name -eq "Windows cannot determine the role of this computer." ) `
	-OR ( $_.Name -eq "Windows cannot determine the user or computer name." ) `
	-OR ( $_.Name -eq "Windows cannot obtain the domain controller name for your computer network." ) `
	-OR ( $_.Name -eq "Windows is setting a registry value" ) `
	-OR ( $_.Name -eq "A DNS server used by this server for name resolution did not respond within the timeout interval" ) `
	-OR ( $_.Name -eq "A resource record for the computer name of the DC is not registered in the DNS database" ) `
	-OR ( $_.Name -eq "One or more of the DC Locator DNS records are not registered in the DNS database since the primary DNS server does not support the dynamic update of the DNS records" ) `
	-OR ( $_.Name -eq "The DNS server with which this DC will register does not support the dynamic update protocol or the authoritative zone is not configured to allow dynamic updates" ) `
	-OR ( $_.Name -eq "The computer did not have sufficient rights to perform the secure dynamic update" ) `
	-OR ( $_.Name -eq "DFS-N: DFS Namespace Service is not Running" ) `
	-OR ( $_.Name -eq "DFS-R: Incompatible AD DS Schema Version" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -like "Proactive DFSR 500* Event for Replication Partner *Monitor" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) `
	-OR ( $_.Name -eq "Proactive Windows Storport Miniport Driver has timed out a request" ) `
}


#====================================
# Filter alerts to server, event description
#====================================
# Break out Open/Closed
#====================================
$OpenADDSAlerts = $ADDSAlerts | ? { $_.ResolutionState -ne "255"}
$OpenSCOMCoreReportAlerts = $SCOMCoreReportAlerts | ? { $_.ResolutionState -ne "255"}

# Debug
$OpenADDSAlerts.Count
$OpenSCOMCoreReportAlerts.Count

$ClosedADDSAlerts = get-scomalert -ResolutionState 255 | ? { ( $_.Name -like "AD *" ) `
	-OR ( $_.Name -eq "DCLocator test failed to locate a domain controller." ) `
	-OR ( $_.Name -like "Group Policy *" ) `
	-OR ( $_.Name -like "Logical disk transfer *" ) `
	-OR ( $_.Name -like "Proactive Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "Replication Partner Count health monitor has failed." ) `
	-OR ( $_.Name -like "The*Availability health monitor has failed." ) `
	-OR ( $_.Name -eq "The Time Skew monitor has failed." ) `
	-OR ( $_.Name -like "Windows DNS *" ) `
	-OR ( $_.Name -eq "A dll cannot be loaded because the software was incorrectly installed" ) `
	-OR ( $_.Name -eq "A RSoP (Resultant Set of Policies) error occurred" ) `
	-OR ( $_.Name -eq "A user from a different forest logged onto this machine. Group policy processing has been effected." ) `
	-OR ( $_.Name -eq "Account creation will fail on this domain controller until the account identifier pool is obtained" ) `
	-OR ( $_.Name -eq "Account Name Not Unique" ) `
	-OR ( $_.Name -eq "An account name collision occurred - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "An attempt to check whether group caching is enabled has failed" ) `
	-OR ( $_.Name -eq "An attempt to set the time was aborted due to the offset being too large" ) `
	-OR ( $_.Name -eq "An attempt to update user credentials failed" ) `
	-OR ( $_.Name -eq "Change Password on KRBTGT Account Failed" ) `
	-OR ( $_.Name -eq "Corrupt Credentials" ) `
	-OR ( $_.Name -eq "DNS registrations of essential Domain controller records is failing" ) `
	-OR ( $_.Name -eq "Domain Operation Mode has been changed to Native Mode" ) `
	-OR ( $_.Name -eq "Duplicate User Principal Names have been detected" ) `
	-OR ( $_.Name -like "Failed to ping or bind*" ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Invalid Forwarded AS Request" ) `
	-OR ( $_.Name -eq "Invalid Policy Data" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Active Directory GPO lookup failure" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Security Configuration Engine error occurred" ) `
	-OR ( $_.Name -eq "Memory Allocation Error - the system may be overloaded" ) `
	-OR ( $_.Name -eq "No input provider to sync time" ) `
	-OR ( $_.Name -eq "PAC Verification Failure" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*" ) `
	-OR ( $_.Name -eq "The account identifier pool for this domain controller cannot be updated" ) `
	-OR ( $_.Name -eq "The computer name cannot be mapped to an object in Active Directory - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "The DC was unable to obtain the next account-identifier" ) `
	-OR ( $_.Name -eq "The domain controller failed to obtain a new account identifier pool" ) `
	-OR ( $_.Name -like "The domain controller has been *" ) `
	-OR ( $_.Name -eq "The group caching option has now been properly updated" ) `
	-OR ( $_.Name -eq "The machine account cannot be found" ) `
	-OR ( $_.Name -eq "The number of Group Policies has exceeded the maximum limit" ) `
	-OR ( $_.Name -eq "The registry policy file could not be accessed during application of machine policy" ) `
	-OR ( $_.Name -eq "The system clock has not been synchronized for some time" ) `
	-OR ( $_.Name -eq "This domain controller will not start up because its machine account has been deleted" ) `
	-OR ( $_.Name -eq "Trusted Domain List Update Failure" ) `
	-OR ( $_.Name -eq "Unexpected SAM Failure" ) `
	-OR ( $_.Name -eq "Windows cannot determine the role of this computer." ) `
	-OR ( $_.Name -eq "Windows cannot determine the user or computer name." ) `
	-OR ( $_.Name -eq "Windows cannot obtain the domain controller name for your computer network." ) `
	-OR ( $_.Name -eq "Windows is setting a registry value" ) `
	-OR ( $_.Name -eq "A DNS server used by this server for name resolution did not respond within the timeout interval" ) `
	-OR ( $_.Name -eq "A resource record for the computer name of the DC is not registered in the DNS database" ) `
	-OR ( $_.Name -eq "One or more of the DC Locator DNS records are not registered in the DNS database since the primary DNS server does not support the dynamic update of the DNS records" ) `
	-OR ( $_.Name -eq "The DNS server with which this DC will register does not support the dynamic update protocol or the authoritative zone is not configured to allow dynamic updates" ) `
	-OR ( $_.Name -eq "The computer did not have sufficient rights to perform the secure dynamic update" ) `
	-OR ( $_.Name -eq "DFS-N: DFS Namespace Service is not Running" ) `
	-OR ( $_.Name -eq "DFS-R: Incompatible AD DS Schema Version" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -like "Proactive DFSR 500* Event for Replication Partner *Monitor" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) `
	-OR ( $_.Name -eq "Proactive Windows Storport Miniport Driver has timed out a request" ) `
}
$ClosedSCOMCoreReportAlerts = @(Get-SCOMAlert -ResolutionState 255 | ? { ( $_.Name -in $UniqSCOMCoreRules.DisplayName ) -OR ( $_.Name -in $UniqSCOMCoreMonitors.DisplayName ) } )

# Debug
$ClosedADDSAlerts.Count
$ClosedSCOMCoreReportAlerts.Count

$TotalAlerts = $ADDSAlerts + $SCOMCoreReportAlerts

$TotalOpenAlerts = $OpenADDSAlerts + $OpenSCOMCoreReportAlerts
$TotalClosedAlerts = $ClosedADDSAlerts + $ClosedSCOMCoreReportAlerts

# Debug
$TotalOpenAlerts.Count
$TotalClosedAlerts.Count

# Parse unique server names to count open alerts
# $OpenADDSAlerts $OpenSCOMCoreRuleAlerts
#=============================================================================================
$UniqADDSAlerts = $TotalOpenAlerts | ? { ( $_.MonitoringObjectDisplayName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	-OR ( $_.NetbiosComputerName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	}
$UniqOpenADDSAlerts = $TotalOpenAlerts | ? { ( $_.MonitoringObjectDisplayName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	-OR ( $_.NetbiosComputerName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	}
$UniqClosedADDSAlerts += $TotalClosedAlerts | ? { ( $_.MonitoringObjectDisplayName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	-OR ( $_.NetbiosComputerName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	}

$UniqOpenADDSAlerts.Count
$UniqClosedADDSAlerts.Count


# Debug for unique servers
$OpenUniqServersALL = $UniqADDSAlerts

$UniqServersMonitoringObjectDisplayName = ( $UniqADDSAlerts | sort -property MonitoringObjectDisplayName -uniq ).MonitoringObjectDisplayName
$UniqServersNetbiosComputerName = ( $UniqADDSAlerts | sort -property NetbiosComputerName -uniq ).NetBiosComputerName
#
# Counts of servers in alerts
$UniqServersMonitoringObjectDisplayName.Count
$UniqServersNetbiosComputerName.Count


$MODN = @()
$UniqMODN = @()

# Break down server names to short, from FQDN
foreach ($LLine in $UniqServersMonitoringObjectDisplayName)
	{
		$Lmatch = $LLine |select-string -pattern '.'
		if ($Lmatch)
		{
			#$Lmatch
			$LLineSplit = $LLine.Split(".")
			$LLineSplit[0]
			#$LLineSplit[1]; $LLineSplit[2]
			#$LLineSplit[3]
			#$LLineSplit2 = $LLineSplit[3].Split("Domain")
			#$LLineSplit2[0]
			$MODN += $LLineSplit[0]
		}
	}

# Display unique server names
$UniqMODN = $MODN | sort -uniq

$UniqServerList = @()
# $UniqServerList = $UniqServersNetbiosComputerName.NetbiosComputerName + $UniqMODN | sort -uniq
$UniqServerList = $UniqMODN | sort -uniq


# $OpenADDSAlerts
$OpenMODNAlerts = @()
$OpenNBCNAlerts = @()
$ClosedMODNAlerts = @()
$ClosedNBCNAlerts = @()
$ComponentAlertSummary = @()


foreach ( $server in $UniqServerList )
	{
	#$server
	$OpenMODNAlerts += $OpenADDSAlerts | ? { $_.MonitoringObjectDisplayName -like "$server*" }
	$OpenNBCNAlerts += $OpenADDSAlerts | ? { $_.NetBiosComputerName -eq $server }
	$ClosedMODNAlerts += $ClosedADDSAlerts | ? { $_.MonitoringObjectDisplayName -like "$server*" }
	$ClosedNBCNAlerts += $ClosedADDSAlerts | ? { $_.NetBiosComputerName -eq $server }

	$OpenUniqAlerts = $OpenMODNAlerts + $OpenNBCNAlerts | sort -uniq
	#$OpenUniqAlerts.Count

	#$ClosedUniqAlerts = $ClosedMODNAlerts + $ClosedNBCNAlerts | sort -uniq
	#$ClosedUniqAlerts.Count

	# Debug for count
	#$OpenMODNAlerts.Count; $OpenNBCNAlerts.Count
	#$ClosedMODNAlerts.Count; $ClosedNBCNAlerts.Count

	$Count = $OpenUniqAlerts.Count
	#$ClosedCount = $ClosedMODNAlerts.Count + $ClosedNBCNAlerts.Count

	write-host "$($server) Log the Count of alerts = $($Count)"

	if ( $Count -gt 5 )
		{
		$ComponentAlertSummary += $server
		$ComponentAlertSummary += $OpenUniqAlerts | ft TimeRaised,Name -auto -wrap
		write-host "Take action due to multiple alert conditions"
		}
	}


#
# Build report

$ADDSComponentMessage = @()

if ( $UniqADDSAlerts.Count -eq 0 )
	{
	$Message = "ZERO ADDS ComponentAlerts for ($date)"
	$ADDSComponentMessage += "ZERO ADDS ComponentAlerts for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $UniqADDSAlerts.Count -gt 0 )
	{
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += $DSMessage
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += "# ADDS ComponentAlert breakdown of degraded AD owned servers"
	$ADDSComponentMessage += "#============================================================"
	$ADDSComponentMessage += "# Total ADDS alerts = $($UniqADDSAlerts.Count)"
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# Open alerts = $($OpenADDSAlerts.Count)"
	$ADDSComponentMessage += "# Closed alerts = $($ClosedADDSAlerts.Count)"
	$ADDSComponentMessage += "#"

	if ( $ComponentAlertSummary.count -eq 0 )
		{
		$ADDSComponentMessage += "#"
		$ADDSComponentMessage += "# ZERO AD owned servers with 5+ alerts"
		$ADDSComponentMessage += "#========================================="
		}

	if ( $ComponentAlertSummary.count -gt 0 )
		{
		$ADDSComponentMessage += "# AD owned servers with 5+ alerts"
		$ADDSComponentMessage += "#========================================="
		$ADDSComponentMessage += $ComponentAlertSummary
		$ADDSComponentMessage += "#========================================="
		$ADDSComponentMessage += ""
		}
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# AD owned servers - Open alert detail"
	$ADDSComponentMessage += "#========================================="
	$ADDSComponentMessage += $OpenUniqAlerts | ft TimeRaised,NetbiosComputerName,Name -auto -wrap
	$ADDSComponentMessage += "#========================================="
	}

$ADDSComponentMessage

$ADDSComponentMessage = $ADDSComponentMessage | out-string


# Log data event before resetting monitors
#============================================================
$Result = "GOOD"
$DSMessage = "Proactive DailyTasks ADDS Monitors close automation for ($date)"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"$DSMessage `n `n$ADDSComponentMessage")
$bag.AddValue('Summary',$ADDSComponentMessage)

# Return all bags
$bag


#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS ComponentAlert DS Script Completed.  Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <WriteActionModuleType ID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Alert.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.DailyTasks.ADDSAlerts.Close.Script.Alert.WA.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather ADDS alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.ADDSAlerts.Close.Script.Datasource.v1047.ps1"
$EventID = "550"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts Close Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-7)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive DailyTasks ADDS Monitors close automation for ($date).")
$Message = "Proactive DailyTasks ADDS Monitors close automation for ($date)."


# Gather AD alerts
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "Active Directory Domain Services for Microsoft Windows Server 2016 and above (Monitoring)"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

# Open/Closed breakout
$OpenADDSAlerts = $SCOMCoreReportAlerts
$OpenADDSAlerts.Count
$ClosedADDSAlerts = Get-SCOMAlert -ResolutionState 255 | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$ClosedADDSAlerts.Count

# Debug - display alerts by server, alert description
#$ADDSAlerts = $SCOMCoreReportAlerts | select MonitoringObjectDisplayName,Description


# Build report
#==========================================================

if ( $SCOMCoreReportAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for ADDS alert closure workflow for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	#
	# Build report
	$ADDSComponentMessage = @()
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += $Message
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += "# ADDS Monitors auto-closed"
	$ADDSComponentMessage += "#============================================================"
	$ADDSComponentMessage += "# Total ADDS alerts = $($SCOMCoreReportAlerts.Count)"
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# Open alerts = $($OpenADDSAlerts.Count)"
	$ADDSComponentMessage += "# Closed alerts = $($ClosedADDSAlerts.Count)"
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# Automation closed alerts = $($OpenADDSAlerts.Count)"
	$ADDSComponentMessage += "#========================================="
	$ADDSComponentMessage += ""
	}

$ADDSComponentMessage

$ADDSComponentMessage = $ADDSComponentMessage | out-string


# Log data event before resetting monitors
#============================================================
  $Result = "GOOD"

  $momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS Monitors close automation for ($date).")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$ADDSComponentMessage)

# Return all bags
$bag



#=================================================================================
# Reset Monitors Script base code modified
# Put ps1 in mgmtpacks folder
# https://sc.scomurr.com/scom-2012-monitor-reset-cleaning-up-the-environment/
#	Download
# https://gallery.technet.microsoft.com/SCOM-2012-Batch-reset-63a17534
	
#Alternate
#https://gallery.technet.microsoft.com/scriptcenter/Auto-reset-script-for-d8b775ca

# Changed up logic to sort unique classes in mgmnt pack families.
# Added Age variable for monitors thanks to Aris Somatis - $Age specified in top level variables
# Cycling through monitors made reset loop huge ~650 monitors when only ~50 classes
# New logic reduced runtime from 8 minutes to roughly 8 seconds
#=================================================================================

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS Monitors reset started for ($date).")


if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	# Get AD classes - Microsoft.Windows.Server.AD.2016.Discovery, Microsoft.Windows.Server.AD.Library
		$ADLibrary = Get-SCOMManagementPack -name "Microsoft.Windows.Server.AD.Class.Library"
			#get-scomclass -ManagementPack $ADLibrary
		$ADMonitoring = $SCOMCoreMP
			# Get-SCOMManagementPack -name "Microsoft.Windows.Server.AD.2016.Monitoring"
			# get-scomclass -ManagementPack $ADMonitoring | fl DisplayName,Name,ID
		$ADDiscovery = Get-SCOMManagementPack -name Microsoft.Windows.Server.AD.2016.Discovery
			#get-scomclass -ManagementPack $ADDiscovery | fl DisplayName,Name,ID

	# ADDS pack naming
	$ADDSClasses = @(Get-SCOMClass -ManagementPack $ADLibrary; Get-SCOMClass -ManagementPack $ADDiscovery; )
	$ADDSClass = $ADDSClasses | sort -property Name -uniq
	# Debug
	$ADDSClass.Count

	# Set up monitor objects to reset
	foreach ($Class in $ADDSClass)
		{
		$ActiveMonitors = @(Get-SCOMClassInstance -Class $Class | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) } )
		# Debug
		$ActiveMonitors.Count
		# $ActiveMonitors | fl -property *
		write-host "Found" $ActiveMonitors.Count "unhealthy monitors for class" $Class
		foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
			{
			#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
			if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
				{
				#$UnhealthyMonitors += $ActiveMonitors.Count
				#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
				#$UnhealthyOLDMonitor.Count
				#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
				#write-host ""
				if ( $ActiveMonitors.Count -gt 0)
					{
					foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
						{
						# Debug
						$ActiveMonitor.ID
						write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
						write-host ""
						$ActiveMonitor.ResetMonitoringState($ActiveMonitor.ID)
						}
					}
				}
			}
		}
	# Debug
	#$MonitorClass | fl -property *
	#$MonitorClass | select DisplayName,ID
	}


# Debug Write event for rule closure
#=================================================================================
# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS monitor reset completed for ($date)")


# Rule closure logic
#=================================================================================
$SCOMCoreRulesToClear = $SCOMCoreRuleAlerts | where { ( $_.TimeAdded -lt $Age ) }
# Convert Age back to days for alert properties logging
$Days = ((Get-date) - $Age).Days
if ( $SCOMCoreRulesToClear.Count -gt 0 )
	{
	$SCOMCoreRulesToClear | Resolve-SCOMAlert -Comment "Closing $Days day old alerts after report alert generated - ADDS Addendum Automation DS"
	}

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS rule reset completed for ($date)")


#=================================================================================
# End MAIN script section
 
  
# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts Close Script Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.WA.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather ADDS alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.WA.v1047.ps1"
$EventID = "553"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts SummaryReport Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather ADDS Alerts for date ($date).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


# Gather AD alerts
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "Active Directory Domain Services for Microsoft Windows Server 2016 and above (Monitoring)"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

$Test = $SCOMCoreReportAlerts.Count


$OpenADDSAlerts = $SCOMCoreReportAlerts
$OpenADDSAlerts.Count
$ClosedADDSAlerts = Get-SCOMAlert -ResolutionState 255  | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$ClosedADDSAlerts.Count


# Break out AD site alerts
# AD Site Performance Health Degraded
# AD Site Availability Health Degraded
$ADDSSiteAlerts = get-scomalert -ResolutionState (0..254) | ? { ( $_.Name -eq "AD Site Performance Health Degraded" ) `
	-OR ( $_.Name -eq "AD Site Availability Health Degraded" ) `
	} | ? { $_.ResolutionState -ne "255"}
	
$ADDSSiteAlerts = $ADDSSiteAlerts | sort -property MonitoringObjectDisplayName -uniq | select MonitoringObjectDisplayName,TimeRaised


# Break out GPO alert section
$GPOAlerts = $(get-scomalert -name "The Group Policy Update health monitor has failed." -ResolutionState (0..254) ).Description

$GPOAlertsDesc = $GPOAlerts.Description
$GPOAlertsDesc.Count

$GPOService = get-scomalert -name "Group Policy Client Service Not Running" -ResolutionState (0..254)
$GPOService.Count

$GPAlerts = $GPOAlerts.count + $GPOService.Count

$GPOErrors = @()

if ( $GPOAlerts.Count -gt 0 )
	{
	foreach ($LLine in $GPOAlerts)
	{
	$LLine; $Lmatch = $LLine |select-string -pattern ':'
	if ($Lmatch)
		{
		#$Lmatch
		$LLineSplit = $LLine.Split(":")
		#write-host "field 2"; $LLineSplit[2]
		$LLine2 = $LLineSplit[2].Split(".")
			write-host "split 2 field 0"; $LLine2[0]
			#write-host "split 2 field 1"; $LLine2[1]
			#write-host "split 2 field 2"; $LLine2[2]
			write-host "split 2 field 3"; $LLine2[3]
			#write-host "split 2 field 4"; $LLine2[4]
			#write-host "split 2 field 5"; $LLine2[5]
			write-host "split 2 field 6"; $LLine2[6]
			#write-host "split 2 field 7"; $LLine2[7]
			write-host "split 2 field 8"; $LLine2[8]
			#write-host "split 2 field 9"; $LLine2[9]
			#write-host "split 2 field 10"; $LLine2[10]
			write-host "split 2 field 11"; $LLine2[11]
		$GPOErrors += $LLine2[0]
		$GPOErrors += $LLine2[3]
		$GPOErrors += $LLine2[6]
		$GPOErrors += $LLine2[8]
		$GPOErrors += $LLine2[11]
		}
	}
}

$GPOErrors

#$GPOErrors.where({ $_ -ne ""})

$Strings = @()
$Strings += "html from the command line to access information about Group Policy results"
$Strings += "The following warnings were encountered"
$Strings += "The processing of Group Policy failed"
$Strings += "User Policy update"
$Strings += "View the event details"
$Strings += "Windows failed to apply the Microsoft Disk Quota settings"
$Strings += "Windows failed to apply the {F312195E-3D9D-447A-A3F5-08DFFA24735E} settings"

#$GPOErrors | ? { ($_.Name -in $Strings) }
$UniqGPOErrors = $GPOErrors | ? { ($_.Name -in $Strings) }

$UniqErrors = $UniqGPOErrors | out-string


# Build out ADDS Time Skew monitors
$ADDSTimeSkew = $SCOMCoreReportAlerts | ? { $_.Name -eq "The Time Skew monitor has failed." `
	} |sort -property NetBiosComputerName
$ADDSTimeSkew.Count


# ADDSATQ
# Build out LSASS process with high CPU alerts
$ADDSATQ = $SCOMCoreReportAlerts | ? { $_.Name -like "The total number of ATQ threads in use has exceeded*" `
	} | sort -property NetBiosComputerName | select NetBiosComputerName,TimeRaise
$ADDSATQ.Count


# Build out LSASS process with high CPU alerts
$ADDSLSASS = $SCOMCoreReportAlerts | ? { $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." `
	} | sort -property NetBiosComputerName | select NetBiosComputerName,TimeRaise
$ADDSLSASS.Count


# Build out Replication alerts
# The AD Replication Queue health monitor has exceeded one or more thresholds.
# AD Show Replication Check health monitor has failed.
# Replication Partner Count health monitor has failed.

$ADDSReplAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -eq "The AD Replication Queue health monitor has exceeded one or more thresholds." ) `
	-OR ( $_.Name -eq "AD Show Replication Check health monitor has failed.") `
	-OR ( $_.Name -eq "Replication Partner Count health monitor has failed." ) `
	} |sort -property NetBiosComputerName | select NetBiosComputerName,TimeRaise 
$ADDSReplAlerts.Count

# Build out remaining ADDS alerts
$Remaining = $SCOMCoreReportAlerts | ? { ( $_.Name -ne "The Group Policy Update health monitor has failed." ) `
	-AND ( $_.Name -ne "AD Show Replication Check health monitor has failed.") `
	-AND ( $_.Name -ne "AD Show The Group Policy Update health monitor has failed.") `
	-AND ( $_.Name -ne "AD Site Performance Health Degraded" ) `
	-AND ( $_.Name -ne "AD Site Availability Health Degraded" ) `
	-AND ( $_.Name -ne "Replication Partner Count health monitor has failed." ) `
	-AND ( $_.Name -ne "The AD Replication Queue health monitor has exceeded one or more thresholds." ) `
	-AND ( $_.Name -ne "The Group Policy Update health monitor has failed." ) `
	-AND ( $_.Name -ne "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-AND ( $_.Name -ne "The Network Adapters DNS Servers health monitor has failed." ) `
	-AND ( $_.Name -ne "The Time Skew monitor has failed." ) `
	-AND ( $_.Name -ne "The total number of ATQ threads in use has exceeded one or more thresholds over multiple samples." ) `
	}
	
$Remaining.Count
$Remaining


# Build report
$ADDSMessage = @()

$ADDSMessage += ""

# Show ADDS alerts by Time Raised,NetBiosComputerName,Message
#
$ADDSMessage += "# ADDS Alert report for $($date)"
$ADDSMessage += "#"
$ADDSMessage += "# Count of NEW ADDS alerts = $($SCOMCoreReportAlerts.Count)"
$ADDSMessage += "#========================================================"
$ADDSMessage += ""


if ( $ADDSTimeSkew.Count -eq 0 )
	{
	$ADDSMessage += "ZERO NTP Time Skew monitors on Domain Controllers"
	$ADDSMessage += ""
	}
	
if ( $ADDSTimeSkew.Count -gt 0 )
	{
	$ADDSMessage += "# NTP Time Skew monitors on Domain Controllers"
	$ADDSMessage += "#============================================="
	if ( $ADDSTimeSkew.Count -lt 10 )
		{
		$ADDSMessage += $ADDSTimeSkew | select NetBiosComputerName,TimeRaised -auto
		}
	if ( $ADDSTimeSkew.Count -ge 10 )
		{
		$ADDSMessage += "The number of Time Skew alerts exceeds 10 since the last report execution"
		}
	$ADDSMessage += "#========================"
	$ADDSMessage += ""
	}


if ( $ADDSATQ.Count -eq 0 )
	{
	$ADDSMessage += "ZERO ADDS Servers with ATQ thread issues"
	$ADDSMessage += ""
	}

if ( $ADDSATQ.Count -gt 0 )
	{
	$ADDSMessage += "# ADDS Servers with ATQ thread issues"
	$ADDSMessage += "#=================================="
	if ( $ADDSATQ.Count -lt 10 )
		{
		$ADDSMessage += $ADDSATQ
		}
	if ( $ADDSATQ.Count -ge 10 )
		{
		$ADDSMessage += "The number of DC's reporting ATQ Thread issues exceeds 10 since the last report execution"
		}
	$ADDSMessage += "#========================"
	$ADDSMessage += ""
	}
	
	
if ( $ADDSLSASS.Count -eq 0 )
	{
	$ADDSMessage += "ZERO LSASS processes with high CPU"
	$ADDSMessage += ""
	}

if ( $ADDSLSASS.Count -gt 0 )
	{
	$ADDSMessage += "# LSASS process has high CPU alerts"
	$ADDSMessage += "#=================================="
	if ( $ADDSLSASS.Count -lt 10 )
		{
		$ADDSMessage += $ADDSLSASS
		}
	if ( $ADDSLSASS.Count -ge 10 )
		{
		$ADDSMessage += "The number of DC's reporting high CPU on LSASS.exe process exceeds 10 since the last report execution"
		}
	$ADDSMessage += "#========================"
	$ADDSMessage += ""
	}


if ( $ADDSReplAlerts.Count -eq 0 )
	{
	$ADDSMessage += "ZERO ADDS Replication alerts"
	$ADDSMessage += ""
	}
	
if ( $ADDSReplAlerts.Count -gt 0 )
	{
	$ADDSMessage += "# ADDS replication alerts"
	$ADDSMessage += "#========================"
	if ( $ADDSReplAlerts.Count -ge 10 )
		{
		$ADDSMessage += "The number of replication alerts exceeds 10 since the last report execution"
		$ADDSMessage += ""
		}
	if ( $ADDSReplAlerts.Count -lt 10 )
		{
		$ADDSMessage += $ADDSReplAlerts
		$ADDSMessage += ""
		}	
	$ADDSMessage += "#==================="
	$ADDSMessage += ""
	}


# GPO alerts
if ( $GPAlerts -gt 0 )
	{
	$ADDSMessage += "ZERO ADDS Group Policy (GPO) alerts"
	$ADDSMessage += ""
	}

if ( $GPAlerts -gt 0 )
	{
	$ADDSMessage += "# Group Policy alerts"
	$ADDSMessage += "#===================="
	$ADDSMessage += "# Total GPO alerts = ($GPAlerts)"
	$ADDSMessage += "#"
	$ADDSMessage += "# Break out of GPO alerts specifically for 'Group Policy Update failed' alerts = $($GPOAlerts.count)"
	$ADDSMessage += "#"
	$ADDSMessage += "#"
	$ADDSMessage += "# Unique GPO errors in past 24 hours"
	$ADDSMessage += "#==================================="
	$ADDSMessage += "$UniqErrors"
	$ADDSMessage += ""
	}
	
if ( $GPOService.Count -eq 0 )
	{
	$ADDSMessage += "ZERO ADDS GPO Service down alerts"
	$ADDSMessage += ""
	}

if ( $GPOService.Count -gt 0 )
	{
	$ADDSMessage += "#================================================================="
	$ADDSMessage += "# GPO service not running - Affected servers (date/time alert cut)"
	$ADDSMessage += "#================================================================="
	$ADDSMessage += $GPOService | select NetbiosComputerName,TimeRaised -auto
	$ADDSMessage += "#================================================================="
	$ADDSMessage += ""
	}


# Remaining ADDS alerts
if ( $Remaining.Count -gt 0 )
	{
	$ADDSMessage += "ZERO Remaining ADDS alerts"
	$ADDSMessage += ""
	}
	
if ( $Remaining.Count -gt 0 )
	{
	$ADDSMessage += "# Remaining ADDS alerts"
	$ADDSMessage += "#========================================================"
	if ( $Remaining.Count -ge 10 )
		{
		$ADDSMessage += "The number of remaining ADDS alerts exceeds 10 since the last report execution"
		$ADDSMessage += ""
		}
	if ( $Remaining.Count -lt 10 )
		{
		$ADDSMessage += ($Remaining | sort -property Name | select TimeRaised,NetbiosComputerName,Name)
		$ADDSMessage += ""
		}
	$ADDSMessage += ""
	$ADDSMessage += "#========================================================"
	$ADDSMessage += ""
	}

$ADDSMessage

$ADDSMessage = $ADDSMessage | out-string


#============================================================

  $Result = "GOOD"
  $Message = "Daily ADDS alerts report for ($date)"

  $momapi.LogScriptEvent($ScriptName,$EventID,0,"ADDS Monitors auto-closed for ($date). `n `n$ADDSMessage")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$ADDSMessage)


# Return all bags
$bag
#=================================================================================
# End MAIN script section
 
  
# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDSAlerts SummaryReport Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.WA.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather ADDS alerts for team daily report
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.WA.v1047.ps1"
$EventID = "564"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive Microsoft Windows Server Addendum AD 2016 Reports Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather ADDS Alerts for date ($date).")
  $Message = "AD Team Daily report for ($date)"


# Gather ADDS alerts
# Monitors then rules
$ADDSReportAlerts = get-scomalert | ? { ( $_.Name -eq "Available Megabytes of Memory is too low" ) `
	-OR ( $_.Name -eq "Certificate lifespan alert" ) `
	-OR ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -like "DFS-R: *" ) `
	-OR ( $_.Name -like "DHCP*" ) `
	-OR ( $_.Name -eq "DHCP Service Stopped" ) `
	-OR ( $_.Name -eq "Disk read latency  is too high" ) `
	-OR ( $_.Name -eq "Disk write latency  is too high" ) `
	-OR ( $_.Name -eq "DNS Client Service Stopped" ) `
	-OR ( $_.Name -eq "Event log is full" ) `
	-OR ( $_.Name -eq "Fail to access site system alert" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Failed to install application on client" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Free System Page Table Entries is too Low." ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -eq "IP address conflict" ) `
	-OR ( $_.Name -eq "LDM - Can't Read Disk" ) `
	-OR ( $_.Name -eq "Logical Disk Fragmentation Level is high" ) `
	-OR ( $_.Name -eq "Logical Disk Free Space is low" ) `
	-OR ( $_.Name -eq "Logical disk idle time percentage is too low" ) `
	-OR ( $_.Name -eq "Logical disk current queue length is too high" ) `
	-OR ( $_.Name -eq "Logical disk transfer (reads and writes) latency  is too high" ) `
	-OR ( $_.Name -eq "Max Concurrent API Reached alert" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Network Adapter Disconnected" ) `
	-OR ( $_.Name -like "Tangible ProV ProVService Service*" ) `
	-OR ( $_.Name -eq "NTFS - File System Corrupt" ) `
	-OR ( $_.Name -eq "NTFS reported the logical disk is in error or corrupt." ) `
	-OR ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -like "PROACTIVE*" ) `
	-OR ( $_.Name -eq "Service entered unpredictable state" ) `
	-OR ( $_.Name -eq "Service is misconfigured" ) `
	-OR ( $_.Name -eq "Service or driver failed to start" ) `
	-OR ( $_.Name -eq "Server Service is misconfigured" ) `
	-OR ( $_.Name -eq "Service terminated unexpectedly" ) `
	-OR ( $_.Name -eq "Share configuration is invalid" ) `
	-OR ( $_.Name -eq "Software update installation failed" ) `
	-OR ( $_.Name -eq "TCP/IP NetBIOS Service Stopped" ) `
	-OR ( $_.Name -eq "The LDAP Bind Time health monitor has exceeded one or more thresholds." ) `
	-OR ( $_.Name -eq "Too many requests for performance counter data have timed out" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "Total DPC Time Percentage is too high" ) `
	-OR ( $_.Name -eq "Total Percentage Interrupt Time is too high" ) `
	-OR ( $_.Name -eq "Used total bandwidth is over threshold" ) `
	-OR ( $_.Name -eq "Used write bandwidth is over threshold" ) `
	-OR ( $_.Name -like "Windows DNS *" ) `
	-OR ( $_.Name -eq "Windows Event Log Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Firewall Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Remote Management Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Required Activation" ) `
	-OR ( $_.Name -eq "Windows Server Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "The Group Policy Update health monitor has failed." ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	}  # | ? { ( $_.TimeRaised -ge $Time ) }

$ADDSReportAlerts.Count


# Open ADDS server alerts
$ADDSServerAlerts = $ADDSReportAlerts | ? { ( $_.NetBiosComputerName -like "DC0*" ) `
	-OR ( $_.NetBiosComputerName -like "*W4NHAAH7*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAA0*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAA1*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAA4*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAA7*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAC1*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AADH*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH0*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH1*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH2*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH3*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH4*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH6*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAH8*" ) `
	-OR ( $_.NetBiosComputerName -like "*W054AAK9*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "DC0*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W4NHAAH7*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAA0*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAA1*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAA4*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAA7*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAC1*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AADH*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH0*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH1*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH2*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH3*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH4*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH6*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAH8*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*W054AAK9*" ) `
	}

# $ADDSServerAlerts 
# $ADDSServerAlerts.Count


# Open ADDS server alerts
$ADDSOpenAlerts = $ADDSServerAlerts | where { $_.ResolutionState -ne "255" }
# $ADDSOpenAlerts.Count

# Open ADDS server alerts since last report
$ADDSAlertsSinceReport = $ADDSOpenAlerts | where { ( $_.TimeRaised -ge $Time ) }
# $ADDSAlertsSinceReport.Count


# Closed ADDS server alerts
$ADDSClosedAlerts = $ADDSServerAlerts | where { $_.ResolutionState -eq "255" }
# $ADDSClosedAlerts.Count

# Closed ADDS server alerts since last report
$ADDSAlertsSinceReport = $ADDSClosedAlerts | where { ( $_.TimeRaised -ge $Time ) }
# $ADDSAlertsSinceReport.Count

$ClosedADDSAlerts = $ADDSClosedAlerts 
# $ClosedADDSAlerts.Count




#
# PROACTIVE - Server restart pending detected
$PendingRestart = $ADDSServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	}

#$PendingRestart.Count

$PendingRestart = $PendingRestart | select NetbiosComputerName,TimeRaised

$OpenPendingRestart = $PendingRestart
# $OpenPendingRestart.Count

$ClosedPendingRestart = $ClosedADDSAlert | ? { ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) }
# $ClosedPendingRestart.Count


#
# PROACTIVE - Server NOT rebooted in past month
$NotRebooted = $ADDSServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) }

#$NotRebooted.Count
$NotRebooted = $NotRebooted | select NetbiosComputerName,TimeRaised

$OpenNotRebooted = $NotRebooted
# $OpenNotRebooted.Count

$ClosedNotRebooted = $ClosedADDSAlert | ? { ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) }
#$ClosedNotRebooted.Count


#
# PROACTIVE - Server NOT patched in past month
$NotPatched = $ADDSServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) }

$NotPatched = $NotPatched | select NetbiosComputerName,TimeRaised

$OpenNotPatched = $NotPatched
#$OpenNotPatched.Count

$ClosedNotPatched = $ClosedADDSAlert | ? { ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) }
#$ClosedNotPatched.Count


# Tangible ProV/DODVisitor DC service
$ProVAlerts = $ADDSServerAlerts | ? { ( $_.Name -like "Tangible ProV*" ) }

#$ProVAlerts.Count
$ProVAlerts | select NetBiosComputerName,TimeRaised

$OpenProVAlerts = $ProVAlerts
#$OpenProVAlerts.Count

$ClosedProVAlerts = $ClosedADDSAlert | ? { ( $_.Name -like "Tangible ProV*" ) }
#$ClosedProVAlerts.Count


# DFS-R alerts
$DFSRAlerts = $ADDSServerAlerts | ? { ( $_.Name -like "DFS-R: *" ) }

#$DFSRAlerts.Count
$DFSRAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenDFSRAlerts = $DFSRAlerts
#$OpenDFSRAlerts.Count

$ClosedDFSRAlerts = $ClosedADDSAlert | ? { ( $_.Name -like "DFS-R: *" ) }
#$ClosedDFSRAlerts.Count


# Windows DNS alerts
$DNSAlerts = $ADDSServerAlerts | ? { ( $_.Name -like "Windows DNS *" ) }

# $DNSAlerts.Count
$DNSAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenDNSAlerts = $DNSAlerts
#$OpenDNSAlerts.Count

$ClosedDNSAlerts = $ClosedADDSAlert | ? { ( $_.Name -like "Windows DNS *" ) }
#$ClosedDNSAlerts.Count


# DHCP alerts
$DHCPAlerts = $ADDSServerAlerts | ? { ( $_.Name -like "DHCP*" ) }

#$DHCPAlerts.Count
$DHCPAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenDHCPAlerts = $DHCPAlerts
#$OpenDHCPAlerts.Count

$ClosedDHCPAlerts = $ClosedADDSAlert | ? { ( $_.Name -like "DHCP*" ) }
#$ClosedDHCPAlerts.Count


# SCCM MECM ConfigMgr alerts
$FailedInstallAlerts = $ADDSServerAlerts | ? { ( $_.Name -eq "Failed to install application on client" ) }

#$FailedInstallAlerts.Count
$FailedInstallAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenFailedInstallAlerts = $FailedInstallAlerts
#$OpenFailedInstallAlerts.Count

$ClosedFailedInstallAlerts = $ClosedADDSAlert | ? { ( $_.Name -eq "Failed to install application on client" ) }
#$ClosedFailedInstallAlerts.Count


# High CPU Memory alerts
$HighAlerts = $ADDSServerAlerts | ? { ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Logical disk transfer (reads and writes) latency is too high" ) `
	}

#$HighAlerts.Count
$HighAlerts | select NetBiosComputerName,TimeRaised,Name

$OpenHighAlerts = $HighAlerts
#$OpenHighAlerts.Count

$ClosedHighAlerts = $ClosedADDSAlert | ? { ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Logical disk transfer (reads and writes) latency is too high" ) `
	}
#$ClosedHighAlerts.Count


# Group Policy GPO alerts
$GPOAlerts = $ADDSServerAlerts | ? { ( $_.Name -eq "The Group Policy Update health monitor has failed." ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	}

#$GPOAlerts.Count

$OpenGPOalerts = $GPOAlerts
#$OpenGPOAlerts.Count

$ClosedGPOAlerts = $ClosedADDSAlert | ? { ( $_.Name -eq "The Group Policy Update health monitor has failed." ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	}
#$ClosedGPOAlerts.Count


#
# Remaining alerts - not Proactive
$ADDSRemaining = @()
$ADDSRemaining = $ADDSOpenAlerts | ? { ( $_.Name -notlike "PROACTIVE - Server*" ) }`
	| ? { ( $_.Name -notlike "Logical disk Free space is low*" ) } `
	| ? { ( $_.Name -notlike "Certificate lifespan alert*" ) } `
	| ? { ( $_.Name -notlike "Tangible ProV*" ) } `
	| ? { ( $_.Name -notlike "DFS-R: *" ) } `
	| ? { ( $_.Name -notlike "Windows DNS *" ) } `
	| ? { ( $_.Name -notlike "DHCP*" ) } `
	| ? { ( $_.Name -ne "Failed to Connect to Computer" ) } `
	| ? { ( $_.Name -ne "Failed to install application on client" ) } `
	| ? { ( $_.Name -ne "Health Service Heartbeat Failure" ) } `
	| ? { ( $_.Name -ne "Percentage of Committed Memory in Use is too high" ) } `
	| ? { ( $_.Name -ne "Tangible ProV ProVService Service*" ) } `
	| ? { ( $_.Name -ne "Total CPU Utilization Percentage is too high" ) } `
	| ? { ( $_.Name -ne "VMware (High): Virtual Machine CPU Usage is High" ) } `
	| ? { ( $_.Name -ne "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) } `
	| ? { ( $_.Name -ne "The Group Policy Update health monitor has failed." ) } `
	| ? { ( $_.Name -ne "Group policy processing aborted - cannot determine site" ) } `
	| ? { ( $_.Name -ne "Policy Update Failure" ) `
	}

$ADDSRemaining

$ADDSFormattedRemaining = $ADDSRemaining | select NetbiosComputerName,TimeRaised,Name


# 
# Unhealthy/Maintenance mode agents
# 
  # Gather Details section
  # $Details = get-scomagent | ? { $_.HealthState -ne "Success" } | select DisplayName| out-string
  #$Details

  $Class = (get-scomclass -Name "Microsoft.Windows.Computer" )
  $instance = ( $Class | ? { $_.Name -like "Microsoft.Windows.Computer" }  |Get-SCOMClassInstance )

  $MM = ($Instance | ? { $_.InMaintenanceMode -eq "True" }).DisplayName `
	| ? { ( $_.DisplayName -like "DC0*" ) `
	-OR ( $_.DisplayName -like "*W4NHAAH7*" ) `
	-OR ( $_.DisplayName -like "*W054AAA0*" ) `
	-OR ( $_.DisplayName -like "*W054AAA1*" ) `
	-OR ( $_.DisplayName -like "*W054AAA4*" ) `
	-OR ( $_.DisplayName -like "*W054AAA7*" ) `
	-OR ( $_.DisplayName -like "*W054AAC1*" ) `
	-OR ( $_.DisplayName -like "*W054AADH*" ) `
	-OR ( $_.DisplayName -like "*W054AAH0*" ) `
	-OR ( $_.DisplayName -like "*W054AAH1*" ) `
	-OR ( $_.DisplayName -like "*W054AAH2*" ) `
	-OR ( $_.DisplayName -like "*W054AAH3*" ) `
	-OR ( $_.DisplayName -like "*W054AAH4*" ) `
	-OR ( $_.DisplayName -like "*W054AAH6*" ) `
	-OR ( $_.DisplayName -like "*W054AAH8*" ) `
	-OR ( $_.DisplayName -like "*W054AAK9*" ) `
	}
	write-host "MM Maintenance mode Agents `n" ; $Unhealthy.InputObject
    $MaintM = $MM | sort | out-string

#   $UnHealthyAgents = get-scomagent
$UnHealthyAgents = ( get-scomagent | ? { $_.HealthState -ne "Success" }).DisplayName `
	| ? { ( $_.DisplayName -like "DC0*" ) `
	-OR ( $_.DisplayName -like "*W4NHAAH7*" ) `
	-OR ( $_.DisplayName -like "*W054AAA0*" ) `
	-OR ( $_.DisplayName -like "*W054AAA1*" ) `
	-OR ( $_.DisplayName -like "*W054AAA4*" ) `
	-OR ( $_.DisplayName -like "*W054AAA7*" ) `
	-OR ( $_.DisplayName -like "*W054AAC1*" ) `
	-OR ( $_.DisplayName -like "*W054AADH*" ) `
	-OR ( $_.DisplayName -like "*W054AAH0*" ) `
	-OR ( $_.DisplayName -like "*W054AAH1*" ) `
	-OR ( $_.DisplayName -like "*W054AAH2*" ) `
	-OR ( $_.DisplayName -like "*W054AAH3*" ) `
	-OR ( $_.DisplayName -like "*W054AAH4*" ) `
	-OR ( $_.DisplayName -like "*W054AAH6*" ) `
	-OR ( $_.DisplayName -like "*W054AAH8*" ) `
	-OR ( $_.DisplayName -like "*W054AAK9*" ) `
	}
	# | ? { ( $_.HealthState -eq "Uninitialized" ) }



if ( ( $UnhealthyAgents.count -gt 0 ) -AND ( $MM.Count -gt 0 ) )
	{
	$CompareMM = compare-object -ReferenceObject $MM -DifferenceObject $UnhealthyAgents
	}
if (  $MM.Count -gt 0 )
	{
	$CompareMM = $MM
	}


  #foreach ( $server in $UnHealthyAgents )
	#{
	#if ( ! $($MaintM | select-string $server) -eq $True )
		#{ 
		#write-host $server "is in Maintenance"
		#$Unhealthy += "$server"
		#}
	#}

  #$Unhealthy
  #$Details = $Unhealthy.InputObject

 
# Check for repeatedly down agents

$DownAgentsAlerts = $ADDSOpenAlerts | where { ($_.Name -eq "Health Service Heartbeat Failure") `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	}


$DownAgentsAlerts.Count
#$DownAgentsAlerts.MonitoringObjectDisplayName | sort -uniq

if ( $DownAgentsAlerts.Count -gt 0 )
	{
	# Open alerts since last report
	$DownAgentsOpenTime = $DownAgentsAlerts | where { $_.TimeRaised -gt $Time }

	# Closed alerts since last report
	$DownAgentsClosedTime = $ClosedADDSAlert | where { ($_.Name -eq "Health Service Heartbeat Failure") `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	} | where { $_.TimeRaised -gt $Time }
	#
	$DownAgentsOpenTime.MonitoringObjectDisplayName | sort -uniq
	$DownAgentsClosedTime.MonitoringObjectDisplayName | sort -uniq
	}


#Get SCOM agents in grey state
# From blog 
# https://www.powershellbros.com/get-list-unhealthy-scom-agents-grey-state-using-powershell/
#
$Agent = Get-SCOMClass -Name Microsoft.Windows.Computer
$Objects = Get-SCOMMonitoringObject -class:$Agent | Where-Object {$_.IsAvailable -eq $false}
$FilteredObjects = $Objects | where { $_.InMaintenanceMode -ne $True } `
	| where { ( $_.DisplayName -like "DC0*" ) `
	-OR ( $_.DisplayName -like "*W4NHAAH7*" ) `
	-OR ( $_.DisplayName -like "*W054AAA0*" ) `
	-OR ( $_.DisplayName -like "*W054AAA1*" ) `
	-OR ( $_.DisplayName -like "*W054AAA4*" ) `
	-OR ( $_.DisplayName -like "*W054AAA7*" ) `
	-OR ( $_.DisplayName -like "*W054AAC1*" ) `
	-OR ( $_.DisplayName -like "*W054AADH*" ) `
	-OR ( $_.DisplayName -like "*W054AAH0*" ) `
	-OR ( $_.DisplayName -like "*W054AAH1*" ) `
	-OR ( $_.DisplayName -like "*W054AAH2*" ) `
	-OR ( $_.DisplayName -like "*W054AAH3*" ) `
	-OR ( $_.DisplayName -like "*W054AAH4*" ) `
	-OR ( $_.DisplayName -like "*W054AAH6*" ) `
	-OR ( $_.DisplayName -like "*W054AAH8*" ) `
	-OR ( $_.DisplayName -like "*W054AAK9*" ) `
	}

$Monitored = $FilteredObjects | where { $_.AvailabilityLastModified -gt $Time } | sort -property DisplayName -uniq
# $Monitored.DisplayName

# Display list of agents/servers and when modified
$FilterMonitored = $Monitored | select AvailabilityLastModified,DisplayName


$NotMonitored = $FilteredObjects | where { $_.AvailabilityLastModified -lt $Time } | sort -property DisplayName -uniq


$RepeatDownAgents = @()
$CurrentDownAgents = @()

# Compare repeated agent down
if ( $DownAgentsOpenTime.Count -eq 0 )
	{
	$RepeatDownAgents += ""
	$RepeatDownAgents += "ZERO Repeated down agents as of report run"
	$RepeatDownAgents += ""
	}
	
if ( $DownAgentsOpenTime.Count -gt 0 )
	{
	# Display list of agents/servers and when modified
	# $FilterMonitored
	If ( $Monitored.Count -gt 0 )
		{
		foreach ( $server in $Monitored.DisplayName)
			{
			$CurrentDownCompare = $DownAgentsOpenTime.MonitoringObjectDisplayName | select-string -simplematch $server
			if ( $CurrentDownCompare.Count -gt 0 )
				{
				$CurrentDownAgents += $server
				}
			$RepeatCount = $NotMonitored.DisplayName | select-string -simplematch $server
			$RepeatCount
			if ( $RepeatCount.Count -gt 0 )
				{
				$RepeatDownAgents += $server
				}
			}
		}
	}

# Debug
#$RepeatDownAgents
#  $RepeatDownAgents.Count
#$CurrentDownAgents
#  $CurrentDownAgents.Count


$UniqOldDownAgentsArray = @()

# Remove whitespace when output contains ZERO
if ( $($($RepeatDownAgents | select-string -simplematch "ZERO" ).Count) -gt 0 )
	{
	$UniqOldDownAgentsArray += "ZERO Repeatcount check NOT monitored servers as of report run"
	}

#if ( $RepeatDownAgents.Count -gt 1 )
if ( $($($RepeatDownAgents | select-string -NOTmatch "ZERO" ).Count) -gt 0 )
	{
	$RepeatDownAgents = $RepeatDownAgents | ? { $_ -and $_.Trim() }
	
	$RepeatDownServers = $RepeatDownAgents  | select-string -NOTmatch "ZERO"
	if ( $RepeatDownServers.Count -gt 0 )
		{
		foreach ( $server in $RepeatDownServers )
			{
			$TestConnectivity = test-netconnection -ComputerName $server -port 5723
			if ( $TestConnectivity.TcpTestSucceeded -eq $False )
				{
				$UniqOldDownAgentsArray += "$server fails TCP5723 connectivity"
				$UniqOldDownAgentsArray += ""
				$UniqOldDownAgentsArray += "Verify Microsoft Monitoring Agent is installed, and healthservice running via 'get-service healthservice'"
				$UniqOldDownAgentsArray += ""
				}
			}
		}
	}

	#$UniqOldDownAgentsArray = $UniqOldDownAgentsArray | ? { $_ -and $_.Trim() }
	$UniqOldDownAgentsArray
	$UniqOldDownAgentsArray = $UniqOldDownAgentsArray | out-string


	#
	#if ( $TestConnectivity.PingSucceeded -eq "False" )
	#	{
	#	$UniqOldDownAgentsArray += "SCOM cannot ping $server, contact network team to resolve firewall issue"
	#	}
	#}



# Analyze down agents
if ( $DownAgents.Count -eq 0 )
	{
	$Compare = $MM.Count + $CompareMM.Count
    $CompareDown = "ZERO NOT monitored servers as of report run"
	}

if ( $DownAgents.Count -gt 0 )
	{
    if ( $UnHealthyAgents.count -gt 0 )
		{
		$CompareDown = compare-object -ReferenceObject $DownAgents -DifferenceObject $UnhealthyAgents
		# Format output of DownAgents
		$Down = $DownAgents | select MonitoringObjectDisplayName,TimeRaised,Name | out-string
		$Down
		}
    if ( $UnHealthyAgents.count -eq 0 )
		{
		$Down = $DownAgents | select MonitoringObjectDisplayName | out-string
		$Down
		}
	}



# Compare Unhealthy agents
$Unhealthy = @()
	
if ( $UnHealthyAgents.Count -eq 0 )
	{
	#$Unhealthy += ""
	$Unhealthy += "ZERO NOT healthy agents as of report run"
	}
	
if ( $UnHealthyAgents.Count -gt 0 )
	{
	#$Unhealthy += ""
	$Unhealthy += $UnHealthyAgents.DisplayName | sort -uniq | out-string
	#$Unhealthy += ""
	}
	
  $Test = $DownAgents.Count +   $UnHealthyAgents.Count
  $Test


# Update to consolidate all the methods into a unique list
#===========================================================
$TotalAgentIssues = @()

if ( $Down -gt 0 )
	{
	$TotalAgentIssues += $Down
	$TotalAgentIssues += ""
	}
if ( $RepeatDownAgents.Count -gt 0 )
	{
	$TotalAgentIssues += $RepeatDownAgents
	$TotalAgentIssues += ""
	}
if ( $Unhealthy.Count -gt 0 )
	{
	$TotalAgentIssues += $Unhealthy
	$TotalAgentIssues += ""
	}
if ( $Monitored.Count -gt 0 )
	{
	$TotalAgentIssues += $Monitored.DisplayName
	$TotalAgentIssues += ""
	}
if ( $NotMonitored.Count -gt 0 )
	{
	$TotalAgentIssues += $NotMonitored.DisplayName
	$TotalAgentIssues += ""
	}

#
#	$TotalAgentIssues = $TotalAgentIssues | ? { $_ -and $_.Trim() }
#	$TotalAgentIssues += ""

$TotalAgentsFiltered = $TotalAgentIssues | ? { $_ -and $_.Trim() } | select-string -NOTmatch "ZERO"

#===============================================
#
# Logical Disk free space alerts
#===============================================

$LDSTest = $ADDSServerAlerts | ? { $_.Name -eq "Logical disk Free space is low" }

if ( $LDSTest.Count -gt 0 )
	{
	$LDSTest

	# Gather details
	$LDSSummary = $LDSTest |select NetbiosComputerName,MonitoringObjectName,Parameters | out-string
	# Gather Details section
	$LDSDetails = $LDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string

	$LDSSummary
	$LDSDetails
  
	$OpenLDSTest = $LDSTest | ? { $_.ResolutionState -ne "255" }
	$OpenLDSTest.Count

	if ( $OpenLDSTest.Count -gt 0 )
		{
		# Summary
		$LDSOpenSummary = $LDSTest | select NetbiosComputerName,MonitoringObjectName,Parameters | out-string
		# Gather Details
		$LDSOpenDetails = $LDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string
		}

	$ClosedLDSTest = $ClosedADDSAlert | ? { $_.Name -eq "Logical disk Free space is low" }
	$ClosedLDSTest.Count

	if ( $ClosedLDSTest.Count -gt 0 )
		{
		# Summary
		$LDSClosedSummary = $ClosedLDSTest | select NetbiosComputerName,MonitoringObjectName,Parameters | out-string
		# Gather Details section
		$LDSClosedDetails = $ClosedLDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string
		}
	}


#===============================================
# Expiring certificates
# Certificates about to expire/expired
#===============================================

$Class = (get-scomclass -DisplayName "Certificate" )
$instance = ( $Class |Get-SCOMClassInstance )
$ADDSPKIexpired = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	# PKI certs can have Certstore, but it's not always searchable/display capable
	# } | ? { $_.CertStore -like "Intermediate Certification*" `
	# PKI certs don't use NetbiosComputerName, and PrincipalName does not output
	} | ? { ( $_.Path -like "DC0*" ) `
	-OR ( $_.Path -like "*W4NHAAH7*" ) `
	-OR ( $_.Path -like "*W054AAA0*" ) `
	-OR ( $_.Path -like "*W054AAA1*" ) `
	-OR ( $_.Path -like "*W054AAA4*" ) `
	-OR ( $_.Path -like "*W054AAA7*" ) `
	-OR ( $_.Path -like "*W054AAC1*" ) `
	-OR ( $_.Path -like "*W054AADH*" ) `
	-OR ( $_.Path -like "*W054AAH0*" ) `
	-OR ( $_.Path -like "*W054AAH1*" ) `
	-OR ( $_.Path -like "*W054AAH2*" ) `
	-OR ( $_.Path -like "*W054AAH3*" ) `
	-OR ( $_.Path -like "*W054AAH4*" ) `
	-OR ( $_.Path -like "*W054AAH6*" ) `
	-OR ( $_.Path -like "*W054AAH8*" ) `
	-OR ( $_.Path -like "*W054AAK9*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName

$ADDSPKIexpired.count

# Intermediate Cert Check
	# PKI certs can have Certstore, but it's not always searchable/display capable
	#} | ? { $_.CertStore -like "Intermediate Certification*" `

$ADDSIntermediate = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { $_.CertStore -like "Intermediate Certification*" }
	# $ADDSIntermediate.Count


$ADDSRootCerts = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { $_.CertStore -like "Root" }
	# $ADDSRootCerts.Count



# Build report
$ADDSTeamReport = @()


# Check for alerts 
if ( $ADDSServerAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for ADDS Team Daily report for ($date)"
	$ADDSTeamReport += "ZERO alerts for ADDS Team Daily report for ($date)"
	$ADDSTeamReport += ""
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $ADDSServerAlerts.Count -gt 0 )
	{
	#
	# Create table output

	#
	# Show ADDS alerts by Time Raised,NetBiosComputerName,Message
	#
	$ADDSTeamReport += $Message
	$ADDSTeamReport += ""
	$ADDSTeamReport += "# ADDS Team Daily report for $($date)"
	$ADDSTeamReport += "#"
	$ADDSTeamReport += "# Alerts since last run = $($ADDSAlertsSinceReport.Count)"
	$ADDSTeamReport += "#"
	$ADDSTeamReport += "# Total OPEN alerts"
	$ADDSTeamReport += "#========================================================"
	$ADDSTeamReport += "# AD Team alerts = $($ADDSOpenAlerts.count)"
	$ADDSTeamReport += ""
	$ADDSTeamReport += "# Server performance alerts = $($OpenHighAlerts.Count)"
	$ADDSTeamReport += "# Logical Disk full alerts = $($OpenLDSTest.Count)"
	$ADDSTeamReport += ""
	$ADDSTeamReport += "# PKI expired certificate alerts = $($ADDSPKIexpired.Count)"
	$ADDSTeamReport += "# PKI Intermediate certificate alerts = $($ADDSIntermediate.Count)"
	$ADDSTeamReport += "# PKI Root certificate alerts = $($ADDSRootCerts.Count)"
	$ADDSTeamReport += ""
 	$ADDSTeamReport += "# Failed to install MECM application packages = $($OpenFailedInstallAlerts.Count)"
	if ( $OpenProVAlerts.Count -gt 0 )
		{
		$ADDSTeamReport += "# Tangible ProV alerts = $($OpenProVAlerts.Count)"
		}
	$ADDSTeamReport += "# DFS-R alerts = $($OpenDFSRAlerts.Count)"
 	$ADDSTeamReport += "# DNS alerts = $($OpenDNSAlerts.Count)"
 	$ADDSTeamReport += "# DHCP alerts = $($OpenDHCPAlerts.Count)"
 	$ADDSTeamReport += "# Group Policy alerts = $($OpenGPOAlerts.Count)"
	$ADDSTeamReport += "#========================================================"
 	$ADDSTeamReport += "# Servers Pending Restart = $($OpenPendingRestart.Count)"
 	$ADDSTeamReport += "# Servers NOT rebooted= $($OpenNotRebooted.Count)"
 	$ADDSTeamReport += "# Servers NOT patched = $($OpenNotPatched.Count)"
 	$ADDSTeamReport += "# Group Policy alerts = $($OpenGPOAlerts.Count)"
	$ADDSTeamReport += ""
 	$ADDSTeamReport += "# Total remaining alerts = $($ADDSRemaining.Count)"
	$ADDSTeamReport += "#========================================================"
	$ADDSTeamReport += ""
	$ADDSTeamReport += "# Monitoring Health details"
	$ADDSTeamReport += "#=========================="


	if ( $TotalAgentsFiltered.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO unmonitored servers as of report run"
		$ADDSTeamReport += ""
		}

	if ( $TotalAgentsFiltered.Count -gt 0 )
		{
		$ADDSTeamReport += "# Total Unhealthy, NOT monitored servers"
		$ADDSTeamReport += "#======================================="
		$ADDSTeamReport += $TotalAgentsFiltered | sort -uniq | out-string
		$ADDSTeamReport += "#======================================="
		$ADDSTeamReport += ""
		}


		# Add logic for agents monitored/down/maintenance mode
	if ( $Test -eq 0)
		{
		$ADDSTeamReport += "ZERO MECM servers NOT monitored for ($date)."
		$ADDSTeamReport += ""
		}
	
	if ( $Test -gt 0)
		{
		$ADDSTeamReport += "# NOT monitored servers for ($date)."
		$ADDSTeamReport += "#================================================"
		$ADDSTeamReport += $Down
		$ADDSTeamReport += ""

		if ( $MM.Count -eq 0)
			{
			$ADDSTeamReport += "ZERO MECM servers in maintenance mode for ($date)."
			$ADDSTeamReport += ""
			}

		if ( $MM.Count -gt 0)
			{
			$ADDSTeamReport += ""
			$ADDSTeamReport += "# Servers in Maintenance Mode MM"
			$ADDSTeamReport += "#==============================="
			$ADDSTeamReport += $MaintM
			$ADDSTeamReport += ""
			$ADDSTeamReport += ""
			}
		}


	if ( $HighAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO Server performance issues for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $HighAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# Server performance alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenHighAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}


	if ( $OpenGPOAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO Group Policy Object issues for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenGPOAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# Group Policy Object (GPO) alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenGPOAlerts | select TimeRaised,NetbiosComputername | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

 	if ( $OpenLDSTest.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS Logical Disk free space alerts for ($date)."
		$ADDSTeamReport += ""
		}
		
	if ( $OpenLDSTest.Count -gt 0 )
		{
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# Summary of Daily Logical Disk free space alerts for ($date)"
		$ADDSTeamReport += "#============================================================"
		$ADDSTeamReport += "#"
		$ADDSTeamReport += "# Logical Disk Free Space alerts"
		$ADDSTeamReport += "#=============================="
		$ADDSTeamReport += $LDSOpenSummary
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# Alert details"
		$ADDSTeamReport += "#=============================="
		$ADDSTeamReport += $LDSOpenDetails
		$ADDSTeamReport += ""
		}

	if ( $ADDSPKIexpired.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS PKI Certificates about to expire for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $ADDSPKIexpired.Count -gt 0 )
		{
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# Certificates about to expire/expired"
		$ADDSTeamReport += "#============================================================"
		$ADDSTeamReport += $ADDSPKIexpired | ft Path,Values -auto -wrap | out-string
		$ADDSTeamReport += ""
		}

	if ( $ADDSIntermediate.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS PKI Intermediate Certificates alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $ADDSIntermediate.Count -gt 0 )
		{
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# ADDS Intermediate Certificate alerts = $($ADDSIntermediate.Count)"
		$ADDSTeamReport += "#============================================================"
		$ADDSTeamReport += $ADDSIntermediate | ft Path,Values -auto -wrap | out-string
		$ADDSTeamReport += ""
		$ADDSTeamReport += "***Execute MANUAL task to disable certs!"
		$ADDSTeamReport += ""
		}

	if ( $ADDSRootCerts.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS PKI Root Certificates alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $ADDSRootCerts.Count -gt 0 )
		{
		$ADDSTeamReport += ""
		$ADDSTeamReport += "# ADDS Root Certificate alerts = $($SharePointIntermediate.Count)"
		$ADDSTeamReport += "#============================================================"
		$ADDSTeamReport += $ADDSRootCerts | ft Path,Values -auto -wrap | out-string
		$ADDSTeamReport += ""
		$ADDSTeamReport += "***Execute MANUAL task to disable certs!"
		$ADDSTeamReport += ""
		}

	if ( $OpenProVAlerts.Count -eq 0 )
		{
		$ADDSTeamReport += "ZERO Tangible ProV alerts for ($date)."
		$ADDSTeamReport += ""
		}
		
	if ( $OpenProVAlerts.Count -gt 0 )
		{
		$ADDSTeamReport += "# Tangible ProV/DODVisitor Service alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenProVAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}


	if ( $OpenDFSRAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO DFS-R alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenDFSRAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# DFS-R alert detail"
		$ADDSTeamReport += "#============================================="
	if ( $OpenDFSRAlerts.count -lt 10 )
		{
		$ADDSTeamReport += $OpenDFSRAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += ""
		}
	if ( $OpenDFSRAlerts.count -ge 10 )
		{
		$ADDSTeamReport += "The number of Windows DFS-R alerts for AD owned servers is greater than 10"
		}
		#$ADDSTeamReport += $OpenDFSRAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenDNSAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO DNS alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenDNSAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# DNS alert detail"
		$ADDSTeamReport += "#============================================="
	if ( $OpenDNSAlerts.count -lt 10 )
		{
		$ADDSTeamReport +=  $DNSAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += ""
		}
	if ( $OpenDNSAlerts.count -ge 10 )
		{
		$ADDSTeamReport += "The number of Windows DNS alerts for AD owned servers is greater than 10"
		}
		#$ADDSTeamReport += $OpenDNSAlerts  | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenDHCPAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO DHCP alerts for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenDHCPAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# DHCP alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenDHCPAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenFailedInstallAlerts.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO MECM install failures for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenFailedInstallAlerts.count -gt 0 )
		{
		$ADDSTeamReport += "# MECM install failure alert detail"
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $OpenFailedInstallAlerts | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}


	if ( $ADDSRemaining.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS remaining Operating System and issues for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $ADDSRemaining.count -gt 0 )
		{
		$ADDSTeamReport += "# Other ADDS application OR Operating System issues "
		$ADDSTeamReport += "#============================================="
		$ADDSTeamReport += $ADDSRemaining | select NetBiosComputerName,TimeRaised,Name | out-string
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenPendingRestart.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS servers pending restart for ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenPendingRestart.count -gt 0 )
		{
		$ADDSTeamReport += "# ADDS servers pending reboot for patches"
		$ADDSTeamReport += "#============================================="
	if ( $OpenPendingRestart.count -lt 10 )
		{
		$ADDSTeamReport += $OpenPendingRestart | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += ""
		}
	if ( $OpenPendingRestart.count -ge 10 )
		{
		$ADDSTeamReport += "The number of AD owned servers pending reboot is greater than 10"
		}
		#$ADDSTeamReport += $OpenPendingRestart | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenNotRebooted.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS servers NOT rebooted in past 35 days as of ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenNotRebooted.count -gt 0 )
		{
		$ADDSTeamReport += "# ADDS servers NOT rebooted (at least 35 days pass before alert)"
		$ADDSTeamReport += "#============================================="

	if ( $OpenNotRebooted.count -lt 10 )
		{
		$ADDSTeamReport += $OpenNotRebooted  | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += ""
		}
	if ( $OpenNotRebooted.count -ge 10 )
		{
		$ADDSTeamReport += "The number of AD owned servers NOT rebooted in past 35 days is greater than 10"
		}
		#$ADDSTeamReport += $OpenNotRebooted | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += "#========================"
		$ADDSTeamReport += ""
		}

	if ( $OpenNotPatched.count -eq 0 )
		{
		$ADDSTeamReport += "ZERO ADDS servers NOT patched in past 35 days as of ($date)."
		$ADDSTeamReport += ""
		}

	if ( $OpenNotPatched.count -gt 0 )
		{
		$ADDSTeamReport += "# ADDS servers not patched (at least 35 days pass before alert)"
		$ADDSTeamReport += "#============================================="
	if ( $OpenNotPatched.count -lt 10 )
		{
		$ADDSTeamReport += $OpenNotPatched | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += ""
		}
	if ( $OpenNotPatched.count -ge 10 )
		{
		$ADDSTeamReport += "The number of AD owned servers NOT rebooted in past 35 days is greater than 10"
		}
		#$ADDSTeamReport += $OpenNotPatched | select NetbiosComputerName,TimeRaised
		$ADDSTeamReport += "#========================"
		}

	$ADDSTeamReport += ""
	}

$ADDSTeamReport


$ADDSTeamReport = $ADDSTeamReport | out-string

#============================================================

  $Result = "GOOD"
  $Message = "AD Team Daily report for ($date)"

  $momapi.LogScriptEvent($ScriptName,$EventID,0,"$ADDSTeamReport")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$ADDSTeamReport)

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive Microsoft Windows Server Addendum AD 2016 Reports Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.DailyTasks.ADDS.ComponentAlert.Script.WA.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather ADDS Component alert consolidation
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.ADDS.ComponentAlert.Script.WA.v1047.ps1"
$EventID = "550"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS ComponentAlert DS Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive DailyTasks ADDS ComponentAlert automation for ($date).")
$DSMessage = "Proactive DailyTasks ADDS ComponentAlert automation for ($date)."


# Gather AD and OS management packs and put into array
#=================================================================================
$ADDSPacks = get-scommanagementpack -DisplayName "Active Directory Domain Services for Microsoft Windows Server 201**Monitoring)"

# Verify if other packs are installed to add to component monitor array

if ( $ADDSPacks.Count -gt 0 )
	{
	$ADMgmtPackArray = @()

	$ADMgmtPackArray += "Active Directory Domain Services for Microsoft Windows Server 2016 and above (Monitoring)"
	$ADMgmtPackArray += "Active Directory Domain Services for Microsoft Windows Server 2012 R2 (Monitoring)"
	$ADMgmtPackArray += "Active Directory Domain Services for Microsoft Windows Server 2012 (Monitoring)"
	$ADMgmtPackArray += "Active Directory Server 2008 and above (Monitoring)"

	$ADMgmtPackArray += "File Services Management Pack for Windows Server 2016 and above"
	$ADMgmtPackArray += "Microsoft Windows Server 2016 and 1709+ DNS Monitoring"
	$ADMgmtPackArray += "Microsoft Windows Server DNS Monitoring"

	$ADMgmtPackArray += "Windows Server 2016+ Active Directory Certificate Services Monitoring"
	$ADMgmtPackArray += "Microsoft Windows Server Active Directory Certificate Services 2012 R2 Monitoring"
	$ADMgmtPackArray += "Microsoft Windows Server Active Directory Certificate Services 2012 Monitoring"

	$ADMgmtPackArray += "Windows Server 2016 and above Operating Systems (Monitoring)"
	$ADMgmtPackArray += "Windows Server 2012 R2 Operating System (Monitoring)"
	$ADMgmtPackArray += "Windows Server 2012 Operating System (Monitoring)"

	$ADMgmtPackArray += "Microsoft Windows Server DHCP 2016 and above"

	$ADMgmtPackArray += "System Center Core Monitoring"
	}


## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
#=================================================================================
$SCOMCoreMP = @()
$SCOMCoreRules = @()
$SCOMCoreMonitors = @()

foreach ( $ADpacks in $ADMgmtPackArray )
	{
	$SCOMCoreMP += Get-SCOMManagementPack -DisplayName $ADpacks

	$SCOMCoreRules += $SCOMCoreMP.GetRules()
	$SCOMCoreMonitors += $SCOMCoreMP.GetMonitors()
	#$SCOMCoreMonitors.Count
	}

	$SCOMCoreMonitors.Count
	$SCOMCoreRules.Count

# Remove duplicates across pack families
$UniqSCOMCoreRules = $SCOMCoreRules | sort -property DisplayName -uniq
$UniqSCOMCoreMonitors =  $SCOMCoreMonitors | sort -property DisplayName -uniq

# Debug
$UniqSCOMCoreRules.Count
$UniqSCOMCoreMonitors.Count

# Tally up the alerts
#=================================================================================
$SCOMCoreReportAlerts = @(Get-SCOMAlert -ResolutionState (0..254) | ? { ( $_.Name -in $UniqSCOMCoreRules.DisplayName ) -OR ( $_.Name -in $UniqSCOMCoreMonitors.DisplayName ) } )
$SCOMCoreMonitortAlerts = @($SCOMCoreReportAlerts | ? { ( $_.Name -in $UniqSCOMCoreMonitors.DisplayName ) } )
$SCOMCoreRuleAlerts = @($SCOMCoreReportAlerts | ? { ( $_.Name -in $UniqSCOMCoreRules.DisplayName ) } )

# Debug
$SCOMCoreReportAlerts.Count
$SCOMCoreMonitortAlerts.Count
$SCOMCoreRuleAlerts.Count

# Call it lack of trust, but rules/monitors name,displayName other than DNS do NOT contain alert names
$ADDSAlerts = @()

$ADDSAlerts = get-scomalert -ResolutionState (0..254) | ? { ( $_.Name -like "AD *" ) `
	-OR ( $_.Name -eq "DCLocator test failed to locate a domain controller." ) `
	-OR ( $_.Name -like "Group Policy *" ) `
	-OR ( $_.Name -like "Logical disk transfer *" ) `
	-OR ( $_.Name -like "Proactive Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "Replication Partner Count health monitor has failed." ) `
	-OR ( $_.Name -like "The*Availability health monitor has failed." ) `
	-OR ( $_.Name -eq "The Time Skew monitor has failed." ) `
	-OR ( $_.Name -like "Windows DNS *" ) `
	-OR ( $_.Name -eq "A dll cannot be loaded because the software was incorrectly installed" ) `
	-OR ( $_.Name -eq "A RSoP (Resultant Set of Policies) error occurred" ) `
	-OR ( $_.Name -eq "A user from a different forest logged onto this machine. Group policy processing has been effected." ) `
	-OR ( $_.Name -eq "Account creation will fail on this domain controller until the account identifier pool is obtained" ) `
	-OR ( $_.Name -eq "Account Name Not Unique" ) `
	-OR ( $_.Name -eq "An account name collision occurred - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "An attempt to check whether group caching is enabled has failed" ) `
	-OR ( $_.Name -eq "An attempt to set the time was aborted due to the offset being too large" ) `
	-OR ( $_.Name -eq "An attempt to update user credentials failed" ) `
	-OR ( $_.Name -eq "Change Password on KRBTGT Account Failed" ) `
	-OR ( $_.Name -eq "Corrupt Credentials" ) `
	-OR ( $_.Name -eq "DNS registrations of essential Domain controller records is failing" ) `
	-OR ( $_.Name -eq "Domain Operation Mode has been changed to Native Mode" ) `
	-OR ( $_.Name -eq "Duplicate User Principal Names have been detected" ) `
	-OR ( $_.Name -like "Failed to ping or bind*" ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Invalid Forwarded AS Request" ) `
	-OR ( $_.Name -eq "Invalid Policy Data" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Active Directory GPO lookup failure" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Security Configuration Engine error occurred" ) `
	-OR ( $_.Name -eq "Memory Allocation Error - the system may be overloaded" ) `
	-OR ( $_.Name -eq "No input provider to sync time" ) `
	-OR ( $_.Name -eq "PAC Verification Failure" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*" ) `
	-OR ( $_.Name -eq "The account identifier pool for this domain controller cannot be updated" ) `
	-OR ( $_.Name -eq "The computer name cannot be mapped to an object in Active Directory - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "The DC was unable to obtain the next account-identifier" ) `
	-OR ( $_.Name -eq "The domain controller failed to obtain a new account identifier pool" ) `
	-OR ( $_.Name -like "The domain controller has been *" ) `
	-OR ( $_.Name -eq "The group caching option has now been properly updated" ) `
	-OR ( $_.Name -eq "The machine account cannot be found" ) `
	-OR ( $_.Name -eq "The number of Group Policies has exceeded the maximum limit" ) `
	-OR ( $_.Name -eq "The registry policy file could not be accessed during application of machine policy" ) `
	-OR ( $_.Name -eq "The system clock has not been synchronized for some time" ) `
	-OR ( $_.Name -eq "This domain controller will not start up because its machine account has been deleted" ) `
	-OR ( $_.Name -eq "Trusted Domain List Update Failure" ) `
	-OR ( $_.Name -eq "Unexpected SAM Failure" ) `
	-OR ( $_.Name -eq "Windows cannot determine the role of this computer." ) `
	-OR ( $_.Name -eq "Windows cannot determine the user or computer name." ) `
	-OR ( $_.Name -eq "Windows cannot obtain the domain controller name for your computer network." ) `
	-OR ( $_.Name -eq "Windows is setting a registry value" ) `
	-OR ( $_.Name -eq "A DNS server used by this server for name resolution did not respond within the timeout interval" ) `
	-OR ( $_.Name -eq "A resource record for the computer name of the DC is not registered in the DNS database" ) `
	-OR ( $_.Name -eq "One or more of the DC Locator DNS records are not registered in the DNS database since the primary DNS server does not support the dynamic update of the DNS records" ) `
	-OR ( $_.Name -eq "The DNS server with which this DC will register does not support the dynamic update protocol or the authoritative zone is not configured to allow dynamic updates" ) `
	-OR ( $_.Name -eq "The computer did not have sufficient rights to perform the secure dynamic update" ) `
	-OR ( $_.Name -eq "DFS-N: DFS Namespace Service is not Running" ) `
	-OR ( $_.Name -eq "DFS-R: Incompatible AD DS Schema Version" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -like "Proactive DFSR 500* Event for Replication Partner *Monitor" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) `
	-OR ( $_.Name -eq "Proactive Windows Storport Miniport Driver has timed out a request" ) `
}


#====================================
# Filter alerts to server, event description
#====================================
# Break out Open/Closed
#====================================
$OpenADDSAlerts = $ADDSAlerts | ? { $_.ResolutionState -ne "255"}
$OpenSCOMCoreReportAlerts = $SCOMCoreReportAlerts | ? { $_.ResolutionState -ne "255"}

# Debug
$OpenADDSAlerts.Count
$OpenSCOMCoreReportAlerts.Count

$ClosedADDSAlerts = get-scomalert -ResolutionState 255 | ? { ( $_.Name -like "AD *" ) `
	-OR ( $_.Name -eq "DCLocator test failed to locate a domain controller." ) `
	-OR ( $_.Name -like "Group Policy *" ) `
	-OR ( $_.Name -like "Logical disk transfer *" ) `
	-OR ( $_.Name -like "Proactive Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "Replication Partner Count health monitor has failed." ) `
	-OR ( $_.Name -like "The*Availability health monitor has failed." ) `
	-OR ( $_.Name -eq "The Time Skew monitor has failed." ) `
	-OR ( $_.Name -like "Windows DNS *" ) `
	-OR ( $_.Name -eq "A dll cannot be loaded because the software was incorrectly installed" ) `
	-OR ( $_.Name -eq "A RSoP (Resultant Set of Policies) error occurred" ) `
	-OR ( $_.Name -eq "A user from a different forest logged onto this machine. Group policy processing has been effected." ) `
	-OR ( $_.Name -eq "Account creation will fail on this domain controller until the account identifier pool is obtained" ) `
	-OR ( $_.Name -eq "Account Name Not Unique" ) `
	-OR ( $_.Name -eq "An account name collision occurred - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "An attempt to check whether group caching is enabled has failed" ) `
	-OR ( $_.Name -eq "An attempt to set the time was aborted due to the offset being too large" ) `
	-OR ( $_.Name -eq "An attempt to update user credentials failed" ) `
	-OR ( $_.Name -eq "Change Password on KRBTGT Account Failed" ) `
	-OR ( $_.Name -eq "Corrupt Credentials" ) `
	-OR ( $_.Name -eq "DNS registrations of essential Domain controller records is failing" ) `
	-OR ( $_.Name -eq "Domain Operation Mode has been changed to Native Mode" ) `
	-OR ( $_.Name -eq "Duplicate User Principal Names have been detected" ) `
	-OR ( $_.Name -like "Failed to ping or bind*" ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Invalid Forwarded AS Request" ) `
	-OR ( $_.Name -eq "Invalid Policy Data" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Active Directory GPO lookup failure" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Security Configuration Engine error occurred" ) `
	-OR ( $_.Name -eq "Memory Allocation Error - the system may be overloaded" ) `
	-OR ( $_.Name -eq "No input provider to sync time" ) `
	-OR ( $_.Name -eq "PAC Verification Failure" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*" ) `
	-OR ( $_.Name -eq "The account identifier pool for this domain controller cannot be updated" ) `
	-OR ( $_.Name -eq "The computer name cannot be mapped to an object in Active Directory - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "The DC was unable to obtain the next account-identifier" ) `
	-OR ( $_.Name -eq "The domain controller failed to obtain a new account identifier pool" ) `
	-OR ( $_.Name -like "The domain controller has been *" ) `
	-OR ( $_.Name -eq "The group caching option has now been properly updated" ) `
	-OR ( $_.Name -eq "The machine account cannot be found" ) `
	-OR ( $_.Name -eq "The number of Group Policies has exceeded the maximum limit" ) `
	-OR ( $_.Name -eq "The registry policy file could not be accessed during application of machine policy" ) `
	-OR ( $_.Name -eq "The system clock has not been synchronized for some time" ) `
	-OR ( $_.Name -eq "This domain controller will not start up because its machine account has been deleted" ) `
	-OR ( $_.Name -eq "Trusted Domain List Update Failure" ) `
	-OR ( $_.Name -eq "Unexpected SAM Failure" ) `
	-OR ( $_.Name -eq "Windows cannot determine the role of this computer." ) `
	-OR ( $_.Name -eq "Windows cannot determine the user or computer name." ) `
	-OR ( $_.Name -eq "Windows cannot obtain the domain controller name for your computer network." ) `
	-OR ( $_.Name -eq "Windows is setting a registry value" ) `
	-OR ( $_.Name -eq "A DNS server used by this server for name resolution did not respond within the timeout interval" ) `
	-OR ( $_.Name -eq "A resource record for the computer name of the DC is not registered in the DNS database" ) `
	-OR ( $_.Name -eq "One or more of the DC Locator DNS records are not registered in the DNS database since the primary DNS server does not support the dynamic update of the DNS records" ) `
	-OR ( $_.Name -eq "The DNS server with which this DC will register does not support the dynamic update protocol or the authoritative zone is not configured to allow dynamic updates" ) `
	-OR ( $_.Name -eq "The computer did not have sufficient rights to perform the secure dynamic update" ) `
	-OR ( $_.Name -eq "DFS-N: DFS Namespace Service is not Running" ) `
	-OR ( $_.Name -eq "DFS-R: Incompatible AD DS Schema Version" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -like "Proactive DFSR 500* Event for Replication Partner *Monitor" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) `
	-OR ( $_.Name -eq "Proactive Windows Storport Miniport Driver has timed out a request" ) `
}
$ClosedSCOMCoreReportAlerts = @(Get-SCOMAlert -ResolutionState 255 | ? { ( $_.Name -in $UniqSCOMCoreRules.DisplayName ) -OR ( $_.Name -in $UniqSCOMCoreMonitors.DisplayName ) } )

# Debug
$ClosedADDSAlerts.Count
$ClosedSCOMCoreReportAlerts.Count

$TotalAlerts = $ADDSAlerts + $SCOMCoreReportAlerts

$TotalOpenAlerts = $OpenADDSAlerts + $OpenSCOMCoreReportAlerts
$TotalClosedAlerts = $ClosedADDSAlerts + $ClosedSCOMCoreReportAlerts

# Debug
$TotalOpenAlerts.Count
$TotalClosedAlerts.Count

# Parse unique server names to count open alerts
# $OpenADDSAlerts $OpenSCOMCoreRuleAlerts
#=============================================================================================
$UniqADDSAlerts = $TotalOpenAlerts | ? { ( $_.MonitoringObjectDisplayName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	-OR ( $_.NetbiosComputerName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	}
$UniqOpenADDSAlerts = $TotalOpenAlerts | ? { ( $_.MonitoringObjectDisplayName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	-OR ( $_.NetbiosComputerName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	}
$UniqClosedADDSAlerts += $TotalClosedAlerts | ? { ( $_.MonitoringObjectDisplayName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	-OR ( $_.NetbiosComputerName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	}

$UniqOpenADDSAlerts.Count
$UniqClosedADDSAlerts.Count


# Debug for unique servers
$OpenUniqServersALL = $UniqADDSAlerts

$UniqServersMonitoringObjectDisplayName = ( $UniqADDSAlerts | sort -property MonitoringObjectDisplayName -uniq ).MonitoringObjectDisplayName
$UniqServersNetbiosComputerName = ( $UniqADDSAlerts | sort -property NetbiosComputerName -uniq ).NetBiosComputerName
#
# Counts of servers in alerts
$UniqServersMonitoringObjectDisplayName.Count
$UniqServersNetbiosComputerName.Count


$MODN = @()
$UniqMODN = @()

# Break down server names to short, from FQDN
foreach ($LLine in $UniqServersMonitoringObjectDisplayName)
	{
		$Lmatch = $LLine |select-string -pattern '.'
		if ($Lmatch)
		{
			#$Lmatch
			$LLineSplit = $LLine.Split(".")
			$LLineSplit[0]
			#$LLineSplit[1]; $LLineSplit[2]
			#$LLineSplit[3]
			#$LLineSplit2 = $LLineSplit[3].Split("Domain")
			#$LLineSplit2[0]
			$MODN += $LLineSplit[0]
		}
	}

# Display unique server names
$UniqMODN = $MODN | sort -uniq

$UniqServerList = @()
# $UniqServerList = $UniqServersNetbiosComputerName.NetbiosComputerName + $UniqMODN | sort -uniq
$UniqServerList = $UniqMODN | sort -uniq


# $OpenADDSAlerts
$OpenMODNAlerts = @()
$OpenNBCNAlerts = @()
$ClosedMODNAlerts = @()
$ClosedNBCNAlerts = @()
$ComponentAlertSummary = @()


foreach ( $server in $UniqServerList )
	{
	#$server
	$OpenMODNAlerts += $OpenADDSAlerts | ? { $_.MonitoringObjectDisplayName -like "$server*" }
	$OpenNBCNAlerts += $OpenADDSAlerts | ? { $_.NetBiosComputerName -eq $server }
	$ClosedMODNAlerts += $ClosedADDSAlerts | ? { $_.MonitoringObjectDisplayName -like "$server*" }
	$ClosedNBCNAlerts += $ClosedADDSAlerts | ? { $_.NetBiosComputerName -eq $server }

	$OpenUniqAlerts = $OpenMODNAlerts + $OpenNBCNAlerts | sort -uniq
	#$OpenUniqAlerts.Count

	#$ClosedUniqAlerts = $ClosedMODNAlerts + $ClosedNBCNAlerts | sort -uniq
	#$ClosedUniqAlerts.Count

	# Debug for count
	#$OpenMODNAlerts.Count; $OpenNBCNAlerts.Count
	#$ClosedMODNAlerts.Count; $ClosedNBCNAlerts.Count

	$Count = $OpenUniqAlerts.Count
	#$ClosedCount = $ClosedMODNAlerts.Count + $ClosedNBCNAlerts.Count

	write-host "$($server) Log the Count of alerts = $($Count)"

	if ( $Count -gt 5 )
		{
		$ComponentAlertSummary += $server
		$ComponentAlertSummary += $OpenUniqAlerts | ft TimeRaised,Name -auto -wrap
		write-host "Take action due to multiple alert conditions"
		}
	}


#
# Build report

$ADDSComponentMessage = @()

if ( $UniqADDSAlerts.Count -eq 0 )
	{
	$Message = "ZERO ADDS ComponentAlerts for ($date)"
	$ADDSComponentMessage += "ZERO ADDS ComponentAlerts for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $UniqADDSAlerts.Count -gt 0 )
	{
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += $DSMessage
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += "# ADDS ComponentAlert breakdown of degraded AD owned servers"
	$ADDSComponentMessage += "#============================================================"
	$ADDSComponentMessage += "# Total ADDS alerts = $($UniqADDSAlerts.Count)"
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# Open alerts = $($OpenADDSAlerts.Count)"
	$ADDSComponentMessage += "# Closed alerts = $($ClosedADDSAlerts.Count)"
	$ADDSComponentMessage += "#"

	if ( $ComponentAlertSummary.count -eq 0 )
		{
		$ADDSComponentMessage += "#"
		$ADDSComponentMessage += "# ZERO AD owned servers with 5+ alerts"
		$ADDSComponentMessage += "#========================================="
		}

	if ( $ComponentAlertSummary.count -gt 0 )
		{
		$ADDSComponentMessage += "# AD owned servers with 5+ alerts"
		$ADDSComponentMessage += "#========================================="
		$ADDSComponentMessage += $ComponentAlertSummary
		$ADDSComponentMessage += "#========================================="
		$ADDSComponentMessage += ""
		}
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# AD owned servers - Open alert detail"
	$ADDSComponentMessage += "#========================================="
	$ADDSComponentMessage += $OpenUniqAlerts | ft TimeRaised,NetbiosComputerName,Name -auto -wrap
	$ADDSComponentMessage += "#========================================="
	}

$ADDSComponentMessage

$ADDSComponentMessage = $ADDSComponentMessage | out-string


# Log data event before resetting monitors
#============================================================
$Result = "GOOD"
$DSMessage = "Proactive DailyTasks ADDS Monitors close automation for ($date)"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"$DSMessage `n `n$ADDSComponentMessage")
$bag.AddValue('Summary',$ADDSComponentMessage)

# Return all bags
$bag


#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS ComponentAlert DS Script Completed.  Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Rule.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Rule.WA.v1047.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  ADDS ComponentAlert script datasource
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
$ScriptName = "Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Rule.DS.v1047.ps1"
$EventID = "550"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS ComponentAlert DS Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive DailyTasks ADDS ComponentAlert automation for ($date).")
$DSMessage = "Proactive DailyTasks ADDS ComponentAlert automation for ($date)."


# Gather AD and OS management packs and put into array
#=================================================================================
$ADDSPacks = get-scommanagementpack -DisplayName "Active Directory Domain Services for Microsoft Windows Server 201**Monitoring)"

# Verify if other packs are installed to add to component monitor array

if ( $ADDSPacks.Count -gt 0 )
	{
	$ADMgmtPackArray = @()

	$ADMgmtPackArray += "Active Directory Domain Services for Microsoft Windows Server 2016 and above (Monitoring)"
	$ADMgmtPackArray += "Active Directory Domain Services for Microsoft Windows Server 2012 R2 (Monitoring)"
	$ADMgmtPackArray += "Active Directory Domain Services for Microsoft Windows Server 2012 (Monitoring)"
	$ADMgmtPackArray += "Active Directory Server 2008 and above (Monitoring)"

	$ADMgmtPackArray += "File Services Management Pack for Windows Server 2016 and above"
	$ADMgmtPackArray += "Microsoft Windows Server 2016 and 1709+ DNS Monitoring"
	$ADMgmtPackArray += "Microsoft Windows Server DNS Monitoring"

	$ADMgmtPackArray += "Windows Server 2016+ Active Directory Certificate Services Monitoring"
	$ADMgmtPackArray += "Microsoft Windows Server Active Directory Certificate Services 2012 R2 Monitoring"
	$ADMgmtPackArray += "Microsoft Windows Server Active Directory Certificate Services 2012 Monitoring"

	$ADMgmtPackArray += "Windows Server 2016 and above Operating Systems (Monitoring)"
	$ADMgmtPackArray += "Windows Server 2012 R2 Operating System (Monitoring)"
	$ADMgmtPackArray += "Windows Server 2012 Operating System (Monitoring)"

	$ADMgmtPackArray += "Microsoft Windows Server DHCP 2016 and above"

	$ADMgmtPackArray += "System Center Core Monitoring"
	}


## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
#=================================================================================
$SCOMCoreMP = @()
$SCOMCoreRules = @()
$SCOMCoreMonitors = @()

foreach ( $ADpacks in $ADMgmtPackArray )
	{
	$SCOMCoreMP += Get-SCOMManagementPack -DisplayName $ADpacks

	$SCOMCoreRules += $SCOMCoreMP.GetRules()
	$SCOMCoreMonitors += $SCOMCoreMP.GetMonitors()
	#$SCOMCoreMonitors.Count
	}

	$SCOMCoreMonitors.Count
	$SCOMCoreRules.Count

# Remove duplicates across pack families
$UniqSCOMCoreRules = $SCOMCoreRules | sort -property DisplayName -uniq
$UniqSCOMCoreMonitors =  $SCOMCoreMonitors | sort -property DisplayName -uniq

# Debug
$UniqSCOMCoreRules.Count
$UniqSCOMCoreMonitors.Count

# Tally up the alerts
#=================================================================================
$SCOMCoreReportAlerts = @(Get-SCOMAlert -ResolutionState (0..254) | ? { ( $_.Name -in $UniqSCOMCoreRules.DisplayName ) -OR ( $_.Name -in $UniqSCOMCoreMonitors.DisplayName ) } )
$SCOMCoreMonitortAlerts = @($SCOMCoreReportAlerts | ? { ( $_.Name -in $UniqSCOMCoreMonitors.DisplayName ) } )
$SCOMCoreRuleAlerts = @($SCOMCoreReportAlerts | ? { ( $_.Name -in $UniqSCOMCoreRules.DisplayName ) } )

# Debug
$SCOMCoreReportAlerts.Count
$SCOMCoreMonitortAlerts.Count
$SCOMCoreRuleAlerts.Count

# Call it lack of trust, but rules/monitors name,displayName other than DNS do NOT contain alert names
$ADDSAlerts = @()

$ADDSAlerts = get-scomalert -ResolutionState (0..254) | ? { ( $_.Name -like "AD *" ) `
	-OR ( $_.Name -eq "DCLocator test failed to locate a domain controller." ) `
	-OR ( $_.Name -like "Group Policy *" ) `
	-OR ( $_.Name -like "Logical disk transfer *" ) `
	-OR ( $_.Name -like "Proactive Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "Replication Partner Count health monitor has failed." ) `
	-OR ( $_.Name -like "The*Availability health monitor has failed." ) `
	-OR ( $_.Name -eq "The Time Skew monitor has failed." ) `
	-OR ( $_.Name -like "Windows DNS *" ) `
	-OR ( $_.Name -eq "A dll cannot be loaded because the software was incorrectly installed" ) `
	-OR ( $_.Name -eq "A RSoP (Resultant Set of Policies) error occurred" ) `
	-OR ( $_.Name -eq "A user from a different forest logged onto this machine. Group policy processing has been effected." ) `
	-OR ( $_.Name -eq "Account creation will fail on this domain controller until the account identifier pool is obtained" ) `
	-OR ( $_.Name -eq "Account Name Not Unique" ) `
	-OR ( $_.Name -eq "An account name collision occurred - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "An attempt to check whether group caching is enabled has failed" ) `
	-OR ( $_.Name -eq "An attempt to set the time was aborted due to the offset being too large" ) `
	-OR ( $_.Name -eq "An attempt to update user credentials failed" ) `
	-OR ( $_.Name -eq "Change Password on KRBTGT Account Failed" ) `
	-OR ( $_.Name -eq "Corrupt Credentials" ) `
	-OR ( $_.Name -eq "DNS registrations of essential Domain controller records is failing" ) `
	-OR ( $_.Name -eq "Domain Operation Mode has been changed to Native Mode" ) `
	-OR ( $_.Name -eq "Duplicate User Principal Names have been detected" ) `
	-OR ( $_.Name -like "Failed to ping or bind*" ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Invalid Forwarded AS Request" ) `
	-OR ( $_.Name -eq "Invalid Policy Data" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Active Directory GPO lookup failure" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Security Configuration Engine error occurred" ) `
	-OR ( $_.Name -eq "Memory Allocation Error - the system may be overloaded" ) `
	-OR ( $_.Name -eq "No input provider to sync time" ) `
	-OR ( $_.Name -eq "PAC Verification Failure" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*" ) `
	-OR ( $_.Name -eq "The account identifier pool for this domain controller cannot be updated" ) `
	-OR ( $_.Name -eq "The computer name cannot be mapped to an object in Active Directory - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "The DC was unable to obtain the next account-identifier" ) `
	-OR ( $_.Name -eq "The domain controller failed to obtain a new account identifier pool" ) `
	-OR ( $_.Name -like "The domain controller has been *" ) `
	-OR ( $_.Name -eq "The group caching option has now been properly updated" ) `
	-OR ( $_.Name -eq "The machine account cannot be found" ) `
	-OR ( $_.Name -eq "The number of Group Policies has exceeded the maximum limit" ) `
	-OR ( $_.Name -eq "The registry policy file could not be accessed during application of machine policy" ) `
	-OR ( $_.Name -eq "The system clock has not been synchronized for some time" ) `
	-OR ( $_.Name -eq "This domain controller will not start up because its machine account has been deleted" ) `
	-OR ( $_.Name -eq "Trusted Domain List Update Failure" ) `
	-OR ( $_.Name -eq "Unexpected SAM Failure" ) `
	-OR ( $_.Name -eq "Windows cannot determine the role of this computer." ) `
	-OR ( $_.Name -eq "Windows cannot determine the user or computer name." ) `
	-OR ( $_.Name -eq "Windows cannot obtain the domain controller name for your computer network." ) `
	-OR ( $_.Name -eq "Windows is setting a registry value" ) `
	-OR ( $_.Name -eq "A DNS server used by this server for name resolution did not respond within the timeout interval" ) `
	-OR ( $_.Name -eq "A resource record for the computer name of the DC is not registered in the DNS database" ) `
	-OR ( $_.Name -eq "One or more of the DC Locator DNS records are not registered in the DNS database since the primary DNS server does not support the dynamic update of the DNS records" ) `
	-OR ( $_.Name -eq "The DNS server with which this DC will register does not support the dynamic update protocol or the authoritative zone is not configured to allow dynamic updates" ) `
	-OR ( $_.Name -eq "The computer did not have sufficient rights to perform the secure dynamic update" ) `
	-OR ( $_.Name -eq "DFS-N: DFS Namespace Service is not Running" ) `
	-OR ( $_.Name -eq "DFS-R: Incompatible AD DS Schema Version" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -like "Proactive DFSR 500* Event for Replication Partner *Monitor" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) `
	-OR ( $_.Name -eq "Proactive Windows Storport Miniport Driver has timed out a request" ) `
}


#====================================
# Filter alerts to server, event description
#====================================
# Break out Open/Closed
#====================================
$OpenADDSAlerts = $ADDSAlerts | ? { $_.ResolutionState -ne "255"}
$OpenSCOMCoreReportAlerts = $SCOMCoreReportAlerts | ? { $_.ResolutionState -ne "255"}

# Debug
$OpenADDSAlerts.Count
$OpenSCOMCoreReportAlerts.Count

$ClosedADDSAlerts = get-scomalert -ResolutionState 255 | ? { ( $_.Name -like "AD *" ) `
	-OR ( $_.Name -eq "DCLocator test failed to locate a domain controller." ) `
	-OR ( $_.Name -like "Group Policy *" ) `
	-OR ( $_.Name -like "Logical disk transfer *" ) `
	-OR ( $_.Name -like "Proactive Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "Replication Partner Count health monitor has failed." ) `
	-OR ( $_.Name -like "The*Availability health monitor has failed." ) `
	-OR ( $_.Name -eq "The Time Skew monitor has failed." ) `
	-OR ( $_.Name -like "Windows DNS *" ) `
	-OR ( $_.Name -eq "A dll cannot be loaded because the software was incorrectly installed" ) `
	-OR ( $_.Name -eq "A RSoP (Resultant Set of Policies) error occurred" ) `
	-OR ( $_.Name -eq "A user from a different forest logged onto this machine. Group policy processing has been effected." ) `
	-OR ( $_.Name -eq "Account creation will fail on this domain controller until the account identifier pool is obtained" ) `
	-OR ( $_.Name -eq "Account Name Not Unique" ) `
	-OR ( $_.Name -eq "An account name collision occurred - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "An attempt to check whether group caching is enabled has failed" ) `
	-OR ( $_.Name -eq "An attempt to set the time was aborted due to the offset being too large" ) `
	-OR ( $_.Name -eq "An attempt to update user credentials failed" ) `
	-OR ( $_.Name -eq "Change Password on KRBTGT Account Failed" ) `
	-OR ( $_.Name -eq "Corrupt Credentials" ) `
	-OR ( $_.Name -eq "DNS registrations of essential Domain controller records is failing" ) `
	-OR ( $_.Name -eq "Domain Operation Mode has been changed to Native Mode" ) `
	-OR ( $_.Name -eq "Duplicate User Principal Names have been detected" ) `
	-OR ( $_.Name -like "Failed to ping or bind*" ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Invalid Forwarded AS Request" ) `
	-OR ( $_.Name -eq "Invalid Policy Data" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Active Directory GPO lookup failure" ) `
	-OR ( $_.Name -eq "Machine account policy failure - Security Configuration Engine error occurred" ) `
	-OR ( $_.Name -eq "Memory Allocation Error - the system may be overloaded" ) `
	-OR ( $_.Name -eq "No input provider to sync time" ) `
	-OR ( $_.Name -eq "PAC Verification Failure" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	-OR ( $_.Name -like "System Center Management Health Service Unloaded System Rule*" ) `
	-OR ( $_.Name -eq "The account identifier pool for this domain controller cannot be updated" ) `
	-OR ( $_.Name -eq "The computer name cannot be mapped to an object in Active Directory - this may result in authentication failures" ) `
	-OR ( $_.Name -eq "The DC was unable to obtain the next account-identifier" ) `
	-OR ( $_.Name -eq "The domain controller failed to obtain a new account identifier pool" ) `
	-OR ( $_.Name -like "The domain controller has been *" ) `
	-OR ( $_.Name -eq "The group caching option has now been properly updated" ) `
	-OR ( $_.Name -eq "The machine account cannot be found" ) `
	-OR ( $_.Name -eq "The number of Group Policies has exceeded the maximum limit" ) `
	-OR ( $_.Name -eq "The registry policy file could not be accessed during application of machine policy" ) `
	-OR ( $_.Name -eq "The system clock has not been synchronized for some time" ) `
	-OR ( $_.Name -eq "This domain controller will not start up because its machine account has been deleted" ) `
	-OR ( $_.Name -eq "Trusted Domain List Update Failure" ) `
	-OR ( $_.Name -eq "Unexpected SAM Failure" ) `
	-OR ( $_.Name -eq "Windows cannot determine the role of this computer." ) `
	-OR ( $_.Name -eq "Windows cannot determine the user or computer name." ) `
	-OR ( $_.Name -eq "Windows cannot obtain the domain controller name for your computer network." ) `
	-OR ( $_.Name -eq "Windows is setting a registry value" ) `
	-OR ( $_.Name -eq "A DNS server used by this server for name resolution did not respond within the timeout interval" ) `
	-OR ( $_.Name -eq "A resource record for the computer name of the DC is not registered in the DNS database" ) `
	-OR ( $_.Name -eq "One or more of the DC Locator DNS records are not registered in the DNS database since the primary DNS server does not support the dynamic update of the DNS records" ) `
	-OR ( $_.Name -eq "The DNS server with which this DC will register does not support the dynamic update protocol or the authoritative zone is not configured to allow dynamic updates" ) `
	-OR ( $_.Name -eq "The computer did not have sufficient rights to perform the secure dynamic update" ) `
	-OR ( $_.Name -eq "DFS-N: DFS Namespace Service is not Running" ) `
	-OR ( $_.Name -eq "DFS-R: Incompatible AD DS Schema Version" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -like "Proactive DFSR 500* Event for Replication Partner *Monitor" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) `
	-OR ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) `
	-OR ( $_.Name -eq "Proactive Windows Storport Miniport Driver has timed out a request" ) `
}
$ClosedSCOMCoreReportAlerts = @(Get-SCOMAlert -ResolutionState 255 | ? { ( $_.Name -in $UniqSCOMCoreRules.DisplayName ) -OR ( $_.Name -in $UniqSCOMCoreMonitors.DisplayName ) } )

# Debug
$ClosedADDSAlerts.Count
$ClosedSCOMCoreReportAlerts.Count

$TotalAlerts = $ADDSAlerts + $SCOMCoreReportAlerts

$TotalOpenAlerts = $OpenADDSAlerts + $OpenSCOMCoreReportAlerts
$TotalClosedAlerts = $ClosedADDSAlerts + $ClosedSCOMCoreReportAlerts

# Debug
$TotalOpenAlerts.Count
$TotalClosedAlerts.Count

# Parse unique server names to count open alerts
# $OpenADDSAlerts $OpenSCOMCoreRuleAlerts
#=============================================================================================
$UniqADDSAlerts = $TotalOpenAlerts | ? { ( $_.MonitoringObjectDisplayName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	-OR ( $_.NetbiosComputerName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	}
$UniqOpenADDSAlerts = $TotalOpenAlerts | ? { ( $_.MonitoringObjectDisplayName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	-OR ( $_.NetbiosComputerName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	}
$UniqClosedADDSAlerts += $TotalClosedAlerts | ? { ( $_.MonitoringObjectDisplayName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	-OR ( $_.NetbiosComputerName -match "\b\w{10}(A0|A1|A4|A7|A9|C1|DH|H0|H1|H2|H3|H4|H6|K9)" ) `
	}

$UniqOpenADDSAlerts.Count
$UniqClosedADDSAlerts.Count


# Debug for unique servers
$OpenUniqServersALL = $UniqADDSAlerts

$UniqServersMonitoringObjectDisplayName = ( $UniqADDSAlerts | sort -property MonitoringObjectDisplayName -uniq ).MonitoringObjectDisplayName
$UniqServersNetbiosComputerName = ( $UniqADDSAlerts | sort -property NetbiosComputerName -uniq ).NetBiosComputerName
#
# Counts of servers in alerts
$UniqServersMonitoringObjectDisplayName.Count
$UniqServersNetbiosComputerName.Count


$MODN = @()
$UniqMODN = @()

# Break down server names to short, from FQDN
foreach ($LLine in $UniqServersMonitoringObjectDisplayName)
	{
		$Lmatch = $LLine |select-string -pattern '.'
		if ($Lmatch)
		{
			#$Lmatch
			$LLineSplit = $LLine.Split(".")
			$LLineSplit[0]
			#$LLineSplit[1]; $LLineSplit[2]
			#$LLineSplit[3]
			#$LLineSplit2 = $LLineSplit[3].Split("Domain")
			#$LLineSplit2[0]
			$MODN += $LLineSplit[0]
		}
	}

# Display unique server names
$UniqMODN = $MODN | sort -uniq

$UniqServerList = @()
# $UniqServerList = $UniqServersNetbiosComputerName.NetbiosComputerName + $UniqMODN | sort -uniq
$UniqServerList = $UniqMODN | sort -uniq


# $OpenADDSAlerts
$OpenMODNAlerts = @()
$OpenNBCNAlerts = @()
$ClosedMODNAlerts = @()
$ClosedNBCNAlerts = @()
$ComponentAlertSummary = @()


foreach ( $server in $UniqServerList )
	{
	#$server
	$OpenMODNAlerts += $OpenADDSAlerts | ? { $_.MonitoringObjectDisplayName -like "$server*" }
	$OpenNBCNAlerts += $OpenADDSAlerts | ? { $_.NetBiosComputerName -eq $server }
	$ClosedMODNAlerts += $ClosedADDSAlerts | ? { $_.MonitoringObjectDisplayName -like "$server*" }
	$ClosedNBCNAlerts += $ClosedADDSAlerts | ? { $_.NetBiosComputerName -eq $server }

	$OpenUniqAlerts = $OpenMODNAlerts + $OpenNBCNAlerts | sort -uniq
	#$OpenUniqAlerts.Count

	#$ClosedUniqAlerts = $ClosedMODNAlerts + $ClosedNBCNAlerts | sort -uniq
	#$ClosedUniqAlerts.Count

	# Debug for count
	#$OpenMODNAlerts.Count; $OpenNBCNAlerts.Count
	#$ClosedMODNAlerts.Count; $ClosedNBCNAlerts.Count

	$Count = $OpenUniqAlerts.Count
	#$ClosedCount = $ClosedMODNAlerts.Count + $ClosedNBCNAlerts.Count

	write-host "$($server) Log the Count of alerts = $($Count)"

	if ( $Count -gt 5 )
		{
		$ComponentAlertSummary += $server
		$ComponentAlertSummary += $OpenUniqAlerts | ft TimeRaised,Name -auto -wrap
		write-host "Take action due to multiple alert conditions"
		}
	}


#
# Build report

$ADDSComponentMessage = @()

if ( $UniqADDSAlerts.Count -eq 0 )
	{
	$Message = "ZERO ADDS ComponentAlerts for ($date)"
	$ADDSComponentMessage += "ZERO ADDS ComponentAlerts for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $UniqADDSAlerts.Count -gt 0 )
	{
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += $DSMessage
	$ADDSComponentMessage += ""
	$ADDSComponentMessage += "# ADDS ComponentAlert breakdown of degraded AD owned servers"
	$ADDSComponentMessage += "#============================================================"
	$ADDSComponentMessage += "# Total ADDS alerts = $($UniqADDSAlerts.Count)"
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# Open alerts = $($OpenADDSAlerts.Count)"
	$ADDSComponentMessage += "# Closed alerts = $($ClosedADDSAlerts.Count)"
	$ADDSComponentMessage += "#"

	if ( $ComponentAlertSummary.count -eq 0 )
		{
		$ADDSComponentMessage += "#"
		$ADDSComponentMessage += "# ZERO AD owned servers with 5+ alerts"
		$ADDSComponentMessage += "#========================================="
		}

	if ( $ComponentAlertSummary.count -gt 0 )
		{
		$ADDSComponentMessage += "# AD owned servers with 5+ alerts"
		$ADDSComponentMessage += "#========================================="
		$ADDSComponentMessage += $ComponentAlertSummary
		$ADDSComponentMessage += "#========================================="
		$ADDSComponentMessage += ""
		}
	$ADDSComponentMessage += "#"
	$ADDSComponentMessage += "# AD owned servers - Open alert detail"
	$ADDSComponentMessage += "#========================================="
	$ADDSComponentMessage += $OpenUniqAlerts | ft TimeRaised,NetbiosComputerName,Name -auto -wrap
	$ADDSComponentMessage += "#========================================="
	}

$ADDSComponentMessage

$ADDSComponentMessage = $ADDSComponentMessage | out-string


# Log data event before resetting monitors
#============================================================
$Result = "GOOD"
$DSMessage = "Proactive DailyTasks ADDS Monitors close automation for ($date)"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"$DSMessage `n `n$ADDSComponentMessage")
$bag.AddValue('Summary',$ADDSComponentMessage)

# Return all bags
$bag


#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS ComponentAlert DS Script Completed.  Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
    </ModuleTypes>
    <MonitorTypes>
      <UnitMonitorType ID="Proactive.ADDS.Repeated.Event.MonitorType" Accessibility="Public">
        <MonitorTypeStates>
          <MonitorTypeState ID="RepeatedEventRaised" NoDetection="false" />
          <MonitorTypeState ID="TimerEventRaised" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="LogName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ErrorExpression" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AutoResolveInterval" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimerWindowInSeconds" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="RepeatCount" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="ErrorDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider">
              <ComputerName>$Config/ComputerName$</ComputerName>
              <LogName>$Config/LogName$</LogName>
            </DataSource>
            <ProbeAction ID="OnDemandReset" TypeID="System!System.PassThroughProbe" />
            <ConditionDetection ID="ErrorFilterCondition" TypeID="System!System.ExpressionFilter">
              <Expression>$Config/ErrorExpression$</Expression>
            </ConditionDetection>
            <ConditionDetection ID="RepeatedDataCondition" TypeID="System!System.ConsolidatorCondition">
              <Consolidator>
                <ConsolidationProperties />
                <TimeControl>
                  <WithinTimeSchedule>
                    <Interval>$Config/TimerWindowInSeconds$</Interval>
                  </WithinTimeSchedule>
                </TimeControl>
                <CountingCondition>
                  <Count>$Config/RepeatCount$</Count>
                  <CountMode>OnNewItemTestOutputRestart_OnTimerSlideByOne</CountMode>
                </CountingCondition>
              </Consolidator>
            </ConditionDetection>
            <ConditionDetection ID="TimerCondition" TypeID="System!System.TimerCondition">
              <TimerWaitInSeconds>$Config/AutoResolveInterval$</TimerWaitInSeconds>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="RepeatedEventRaised">
              <Node ID="RepeatedDataCondition">
                <Node ID="ErrorFilterCondition">
                  <Node ID="ErrorDataSource" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="TimerEventRaised">
              <Node ID="TimerCondition">
                <Node ID="RepeatedDataCondition">
                  <Node ID="ErrorFilterCondition">
                    <Node ID="ErrorDataSource" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="TimerEventRaised">
              <Node ID="OnDemandReset" />
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Proactive.ADDS.Service.Monitor.MonitorType" Accessibility="Public">
        <MonitorTypeStates>
          <MonitorTypeState ID="Running" NoDetection="false" />
          <MonitorTypeState ID="NotRunning" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ServiceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="CheckStartupType" minOccurs="0" maxOccurs="1" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Samples" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="CheckStartupType" Selector="$Config/CheckStartupType$" ParameterType="string" />
          <OverrideableParameter ID="Samples" Selector="$Config/Samples$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.Win32ServiceInformationProvider">
              <ComputerName>$Config/ComputerName$</ComputerName>
              <ServiceName>$Config/ServiceName$</ServiceName>
              <Frequency>$Config/IntervalSeconds$</Frequency>
              <DisableCaching>true</DisableCaching>
              <CheckStartupType>$Config/CheckStartupType$</CheckStartupType>
            </DataSource>
            <ProbeAction ID="Probe" TypeID="Windows!Microsoft.Windows.Win32ServiceInformationProbe">
              <ComputerName>$Config/ComputerName$</ComputerName>
              <ServiceName>$Config/ServiceName$</ServiceName>
            </ProbeAction>
            <ConditionDetection ID="ServiceRunning" TypeID="System!System.ExpressionFilter">
              <Expression>
                <Or>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Property[@Name='StartMode']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value Type="Integer">4</Value>
                        <!-- 0=BootStart 1=SystemStart 2=Automatic 3=Manual 4=Disabled -->
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Property[@Name='State']</XPathQuery>
                      </ValueExpression>
                      <Operator>Equal</Operator>
                      <ValueExpression>
                        <Value Type="Integer">4</Value>
                        <!-- 0=Unknown 1=Stopped 2=StartPending 3=StopPending 4=Running 5=ContinuePending 6=PausePending 7=Paused 8=ServiceNotFound 9=ServerNotFound -->
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </Or>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="ServiceNotRunning" TypeID="System!System.ExpressionFilter">
              <Expression>
                <And>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Property[@Name='StartMode']</XPathQuery>
                      </ValueExpression>
                      <Operator>NotEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">4</Value>
                        <!-- 0=BootStart 1=SystemStart 2=Automatic 3=Manual 4=Disabled -->
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                  <Expression>
                    <SimpleExpression>
                      <ValueExpression>
                        <XPathQuery Type="Integer">Property[@Name='State']</XPathQuery>
                      </ValueExpression>
                      <Operator>NotEqual</Operator>
                      <ValueExpression>
                        <Value Type="Integer">4</Value>
                        <!-- 0=Unknown 1=Stopped 2=StartPending 3=StopPending 4=Running 5=ContinuePending 6=PausePending 7=Paused 8=ServiceNotFound 9=ServerNotFound -->
                      </ValueExpression>
                    </SimpleExpression>
                  </Expression>
                </And>
              </Expression>
              <SuppressionSettings>
                <MatchCount>$Config/Samples$</MatchCount>
              </SuppressionSettings>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Running">
              <Node ID="ServiceRunning">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="NotRunning">
              <Node ID="ServiceNotRunning">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="Running">
              <Node ID="ServiceRunning">
                <Node ID="Probe" />
              </Node>
            </OnDemandDetection>
            <OnDemandDetection MonitorTypeStateID="NotRunning">
              <Node ID="ServiceNotRunning">
                <Node ID="Probe" />
              </Node>
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
    </MonitorTypes>
  </TypeDefinitions>
  <Monitoring>
    <Rules>
      <Rule ID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.DailyTasks.ADDSAlerts.Close.Script.DataSource">
            <TimeoutSeconds>2700</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDSAlerts.Close.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Count']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Message']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Task.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">551</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Proactive DailyTasks ADDS Monitors close automation for</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDSAlerts.Close.Script.Task.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.DataSource">
            <TimeoutSeconds>600</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Count']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Message']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Task.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">553</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>ADDS 2016 Alert Summary report for</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Task.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.Datasource">
            <TimeoutSeconds>2700</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Count']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Message']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Task.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">564</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>AD Team Daily report for </Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Task.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyFailed.Alert.Rule" Enabled="false" Target="Windows!Microsoft.Windows.Server.OperatingSystem" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Microsoft-Windows-GroupPolicy/Operational</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">7016</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventLevel</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Error</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyFailed.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyObjectsFiltered.Alert.Rule" Enabled="false" Target="Windows!Microsoft.Windows.Server.OperatingSystem" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Microsoft-Windows-GroupPolicy/Operational</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">5313</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>The following Group Policy objects were not applicable because they were filtered out</Pattern>
                  </RegExExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>DoesNotContainSubstring</Operator>
                    <Pattern>None</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyObjectsFiltered.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyFailed.Alert.Rule" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Microsoft-Windows-GroupPolicy/Operational</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">7016</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>The following Group Policy objects were not applicable because they were filtered out</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyFailed.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyObjectsFiltered.Alert.Rule" Enabled="false" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Microsoft-Windows-GroupPolicy/Operational</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">5313</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>DoesNotContainSubstring</Operator>
                    <Pattern>None</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyObjectsFiltered.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDS.ComponentAlert.Report.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.DataSource">
            <TimeoutSeconds>900</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDS.ComponentAlert.Report.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Summary']$</AlertParameter1>
            </AlertParameters>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Custom</Category>
        <DataSources>
          <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
            <Scheduler>
              <SimpleReccuringSchedule>
                <Interval Unit="Seconds">3602</Interval>
                <SyncTime>00:02</SyncTime>
              </SimpleReccuringSchedule>
              <ExcludeDates />
            </Scheduler>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Rule.WA">
            <TimeoutSeconds>300</TimeoutSeconds>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Event.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">550</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Proactive DailyTasks ADDS ComponentAlert automation task for</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Event.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.Task.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">550</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Proactive DailyTasks ADDS ComponentAlert automation task for</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.ADDS.ComponentAlert.Script.Task.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.NotFound.Recovery.Rule" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">3751</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">Params/Param[2]</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>GroupPolicyClient</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.NotFound.Recovery.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data[Default='']/EventDisplayNumber$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/PublisherName$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/LoggingComputer$</SuppressionValue>
            </Suppression>
            <Custom1 />
            <Custom2 />
            <Custom3 />
            <Custom4 />
            <Custom5 />
            <Custom6 />
            <Custom7 />
            <Custom8 />
            <Custom9 />
            <Custom10 />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.FoundRunning.Recovery.Rule" Enabled="false" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">3752</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">Params/Param[2]</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>GroupPolicyClient</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.FoundRunning.Recovery.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data[Default='']/EventDisplayNumber$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/PublisherName$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/LoggingComputer$</SuppressionValue>
            </Suppression>
            <Custom1 />
            <Custom2 />
            <Custom3 />
            <Custom4 />
            <Custom5 />
            <Custom6 />
            <Custom7 />
            <Custom8 />
            <Custom9 />
            <Custom10 />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.RecoveryFailed.Recovery.Rule" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">3753</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">Params/Param[2]</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>GroupPolicyClient</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.RecoveryFailed.Recovery.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data[Default='']/EventDisplayNumber$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/PublisherName$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/LoggingComputer$</SuppressionValue>
            </Suppression>
            <Custom1 />
            <Custom2 />
            <Custom3 />
            <Custom4 />
            <Custom5 />
            <Custom6 />
            <Custom7 />
            <Custom8 />
            <Custom9 />
            <Custom10 />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.TooManyRecoveryAttempts.Recovery.Rule" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">3754</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">Params/Param[2]</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>GroupPolicyClient</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.TooManyRecoveryAttempts.Recovery.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data[Default='']/EventDisplayNumber$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/PublisherName$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/LoggingComputer$</SuppressionValue>
            </Suppression>
            <Custom1 />
            <Custom2 />
            <Custom3 />
            <Custom4 />
            <Custom5 />
            <Custom6 />
            <Custom7 />
            <Custom8 />
            <Custom9 />
            <Custom10 />
          </WriteAction>
        </WriteActions>
      </Rule>
    </Rules>
    <Tasks>
      <Task ID="Proactive.DailyTasks.ADDSAlerts.Report.Script.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Alert.WA">
          <TimeoutSeconds>2700</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.WA">
          <TimeoutSeconds>600</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Proactive.DailyTasks.AD.2016.Team.Report.Script.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.WA">
          <TimeoutSeconds>600</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.WA">
          <TimeoutSeconds>900</TimeoutSeconds>
        </WriteAction>
      </Task>
    </Tasks>
    <Monitors>
      <UnitMonitor ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.AvailabilityState.Monitor" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Proactive.ADDS.Service.Monitor.MonitorType" ConfirmDelivery="true">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.AvailabilityState.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='Name']$</AlertParameter1>
            <AlertParameter2>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Running" MonitorTypeStateID="Running" HealthState="Success" />
          <OperationalState ID="NotRunning" MonitorTypeStateID="NotRunning" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName />
          <ServiceName>gpsvc</ServiceName>
          <IntervalSeconds>300</IntervalSeconds>
          <CheckStartupType>true</CheckStartupType>
          <Samples>3</Samples>
        </Configuration>
      </UnitMonitor>
    </Monitors>
    <Recoveries>
      <Recovery ID="DFS.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.DFS.ServiceCheck" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="WA.IsmServ" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>C:\windows\system32</WorkingDirectory>
          <CommandLine>start dfs</CommandLine>
          <TimeoutSeconds>15</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
      <Recovery ID="NTDS.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.NTDS.ServiceCheck" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="WA.IsmServ" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>C:\windows\system32</WorkingDirectory>
          <CommandLine>start ntds</CommandLine>
          <TimeoutSeconds>15</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
      <Recovery ID="DFSR.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainController.SYSVOL.DFSR" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.DFSR.ServiceCheck" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="WA.IsmServ" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>C:\windows\system32</WorkingDirectory>
          <CommandLine>start DFSR</CommandLine>
          <TimeoutSeconds>15</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
      <Recovery ID="IsmServ.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.ISM.ServiceCheck" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="WA.IsmServ" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>C:\windows\system32</WorkingDirectory>
          <CommandLine>start IsmServ</CommandLine>
          <TimeoutSeconds>15</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
      <Recovery ID="KDC.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.KDC.ServiceCheck" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="WA.IsmServ" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>C:\windows\system32</WorkingDirectory>
          <CommandLine>start KDC</CommandLine>
          <TimeoutSeconds>15</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
      <Recovery ID="NetLogon.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.NetLogon.ServiceCheck" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="WA.IsmServ" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>C:\windows\system32</WorkingDirectory>
          <CommandLine>start NetLogon</CommandLine>
          <TimeoutSeconds>15</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
      <Recovery ID="NTFRS.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainController.SYSVOL.NTFRS" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.NTFRS.ServiceCheck" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="WA.IsmServ" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>C:\windows\system32</WorkingDirectory>
          <CommandLine>start NtFrs</CommandLine>
          <TimeoutSeconds>15</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
      <Recovery ID="W32Time.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.W32Time.ServiceCheck" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="WA.IsmServ" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>C:\windows\system32</WorkingDirectory>
          <CommandLine>start W32Time</CommandLine>
          <TimeoutSeconds>15</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
      <Recovery ID="GroupPolicy.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.GroupPolicy.ServiceCheck" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
          <ScriptName>Microsoft.Windows.GPSvc.Service.Monitor.Recovery.v1055.ps1</ScriptName>
          <ScriptBody>
#=================================================================================
#  Script to restart a service
#
#  Author:  Kevin Holman
#
#  Version:  1.0
#
#=================================================================================


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ServiceName = "gpsvc"
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging
$ScriptName = "Microsoft.Windows.GPSvc.Service.Monitor.Recovery.v1055.ps1"
$EventID = "3750"
#=================================================================================


# Starting Script section
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#=================================================================================


# Begin MAIN script section
#=================================================================================

[string]$ServiceName = "gpsvc"

#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Recovery script for service: ($ServiceName) is starting. `n Running as ($whoami).")
write-host "Recovery script for service: ($ServiceName) is starting. Running as ($whoami)."

#Get the service object
$Svc = Get-Service $ServiceName

#Check to ensure the service exists:
IF (!$Svc)
{
  $momapi.LogScriptEvent($ScriptName,3751,2, "`n Service ($ServiceName) was not found on this computer. `n This indicates a misconfiguration of the monitor. `n Error is ($error)")
  write-host "Service ($ServiceName) was not found on this computer. This indicates a misconfiguration of the monitor. Error is ($error)"
  EXIT
}

#Get Service Status:
[string]$SvcStatus = $Svc.Status

#Do not continue is service is already running
IF ($SvcStatus -eq "Running")
{
  $momapi.LogScriptEvent($ScriptName,3752,2, "`n Service ($ServiceName) was found to be in the Running state. `n This indicates a misconfiguration of the monitor. `n No recovery action will be taken.")
  write-host "Service ($ServiceName) was found to be in the Running state. This indicates a misconfiguration of the monitor. No recovery action will be taken."
  EXIT  
}

#Log recovery information event
$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Service: ($ServiceName) was found to be in the ($SvcStatus) state.  Recovery will be attempted.")
write-host "Service: ($ServiceName) was found to be in the ($SvcStatus) state.  Recovery will be attempted."

#Attempt First Recovery
Restart-Service -Name $ServiceName -Force
#Wait time in seconds
Start-Sleep 20
#Get the service object
$Svc = Get-Service $ServiceName
#Get Service Status:
$SvcStatus = $Svc.Status

IF ($SvcStatus -ne "Running")
{
  #Attempt Second Recovery
  $momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Service: ($ServiceName) second attempt at recovering starting now.")
  write-host "Service: ($ServiceName) second attempt at recovering starting now."  
  Restart-Service -Name $ServiceName -Force
  Start-Sleep 20
  $Svc = Get-Service $ServiceName
  $SvcStatus = $Svc.Status 
}

IF ($SvcStatus -ne "Running")
{
  #Attempt Third Recovery
  $momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Service: ($ServiceName) third attempt at recovering starting now.")
  write-host "Service: ($ServiceName) third attempt at recovering starting now."    
  Restart-Service -Name $ServiceName -Force
  Start-Sleep 20
  $Svc = Get-Service $ServiceName
  $SvcStatus = $Svc.Status 
}

IF ($SvcStatus -eq "Running")
{
  #Log event of a successful restart
  $momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Service: ($ServiceName) was successfully restarted and then detected to be in the Running state.")
  write-host "Service: ($ServiceName) was successfully restarted and then detected to be in the Running state."
}
ELSE
{
  #Log event of a successful restart
  $momapi.LogScriptEvent($ScriptName,3753,2,"`n Service: ($ServiceName) is not running. `n Recovery was attempted and failed. `n Manual interventon is required. `n The last detected service status was ($SvcStatus).") 
  write-host "Service: ($ServiceName) is not running. Recovery was attempted and failed. Manual interventon is required. The last detected service status was ($SvcStatus)."
}

# Check to see if this recovery script has been run multiple times in the last x minutes for detection of too many recovery actions
$Message = "*($ServiceName) is starting*"
$Events = Get-GroupPolicyClient -LogName 'Operations Manager' -After $StartTime.AddMinutes(-60) -Message $Message | where {$_.EventID -eq 3750}
$EventCount = $Events.Count
IF ($EventCount -ge 3)
{
  $momapi.LogScriptEvent($ScriptName,3754,2,"`n Too many service recoveries have been attempted for ($ServiceName). `n ($EventCount) recoveries are detected in the event log. `n Manual interventon is required.")
  write-host "Too many service recoveries have been attempted for ($ServiceName). ($EventCount) recoveries are detected in the event log. Manual interventon is required."
}

# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
write-host "Script Completed. Script Runtime: ($ScriptTime) seconds."
#=================================================================================
# End of script		  
		  </ScriptBody>
          <TimeoutSeconds>300</TimeoutSeconds>
        </WriteAction>
      </Recovery>
      <Recovery ID="ADWS.Service.Recovery.Task" Accessibility="Public" Enabled="true" Target="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.ADWS.ServiceCheck" ResetMonitor="true" ExecuteOnState="Warning" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="WA.IsmServ" TypeID="System!System.CommandExecuter">
          <ApplicationName>%windir%\system32\net.exe</ApplicationName>
          <WorkingDirectory>C:\windows\system32</WorkingDirectory>
          <CommandLine>start Adws</CommandLine>
          <TimeoutSeconds>15</TimeoutSeconds>
          <RequireOutput>true</RequireOutput>
        </WriteAction>
      </Recovery>
    </Recoveries>
    <Overrides>
      <MonitorConfigurationOverride ID="Override.Microsoft.Windows.Server.2016.AD.Configuration.ReplicationPartnerCount.Monitor" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.Configuration.ReplicationPartnerCount.Monitor" Parameter="ConnectionsThresholdWarning">
        <Value>55</Value>
      </MonitorConfigurationOverride>
      <MonitorConfigurationOverride ID="Override.IntervalSeconds.Microsoft.Windows.Server.2016.AD.Performance.GCResponse.Monitor" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.Performance.GCResponse.Monitor" Parameter="IntervalSeconds">
        <Value>900</Value>
      </MonitorConfigurationOverride>
      <MonitorConfigurationOverride ID="Override.IntervalSeconds.Microsoft.Windows.Server.2016.AD.Availability.GCResponse.Monitor" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.Availability.GCResponse.Monitor" Parameter="IntervalSeconds">
        <Value>918</Value>
      </MonitorConfigurationOverride>
      <MonitorConfigurationOverride ID="Override.NumSamples.Microsoft.Windows.Server.2016.AD.Performance.GCResponse.Monitor" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.Performance.GCResponse.Monitor" Parameter="NumSamples">
        <Value>4</Value>
      </MonitorConfigurationOverride>
      <MonitorConfigurationOverride ID="Override.IntervalSeconds.Microsoft.Windows.Server.2016.AD.Configuration.NetworkAdapters.DNS.Monitor" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.Configuration.NetworkAdapters.DNS.Monitor" Parameter="IntervalSeconds">
        <Value>902</Value>
      </MonitorConfigurationOverride>
      <MonitorPropertyOverride ID="Override.Disable.Microsoft.Windows.Server.2016.AD.Configuration.NetworkAdapters.DNS.Monitor" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.Configuration.NetworkAdapters.DNS.Monitor" Property="Enabled">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Disable.Microsoft.Windows.Server.AD.Library.Site.AvailRollupMonitor" Context="MWSAL!Microsoft.Windows.Server.AD.Library.Site" Enforced="false" Monitor="MWSAL!Microsoft.Windows.Server.AD.Library.Site.AvailRollupMonitor" Property="Enabled">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Severity.Microsoft.Windows.Server.2016.AD.Performance.Atq.AvgThreads.Monitor" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.Performance.Atq.AvgThreads.Monitor" Property="AlertSeverity">
        <Value>Warning</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Disable.Microsoft.Windows.Server.2016.AD.Performance.Atq.AvgThreads.Monitor" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.Performance.Atq.AvgThreads.Monitor" Property="Enabled">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Disable.Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.GroupPolicy.ServiceCheck.Monitor" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.GlobalCatalogServerRole" Enforced="false" Monitor="MWSA6M!Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.GroupPolicy.ServiceCheck" Property="Enabled">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <RulePropertyOverride ID="Override.A_RSoP__Resultant_Set_of_Policies__error_occurred_5_Rule" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!A_RSoP__Resultant_Set_of_Policies__error_occurred_5_Rule" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.Windows.Server.2016.AD.DirectoryService.Error.EventCollection" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Microsoft.Windows.Server.2016.AD.DirectoryService.Error.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Unexpected_SAM_Failure_5_Rule" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Unexpected_SAM_Failure_5_Rule" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.PAC_Verification_Failure_5_Rule" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!PAC_Verification_Failure_5_Rule" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.Windows.Server.2016.AD.DFSReplication.Warning.EventCollection" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Microsoft.Windows.Server.2016.AD.DFSReplication.Warning.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.Windows.Server.2016.AD.DirectoryService.Warning.EventCollection" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Microsoft.Windows.Server.2016.AD.DirectoryService.Warning.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.Windows.Server.2016.AD.DFSReplication.Error.EventCollection" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Microsoft.Windows.Server.2016.AD.DFSReplication.Error.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Machine_account_policy_failure___Active_Directory_GPO_lookup_failure_5_Rule" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Machine_account_policy_failure___Active_Directory_GPO_lookup_failure_5_Rule" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Windows_cannot_obtain_the_domain_controller_name_for_your_computer_network._5_Rule" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Windows_cannot_obtain_the_domain_controller_name_for_your_computer_network._5_Rule" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.Windows.Server.2016.AD.ActiveDirectoryWebServices.Error.EventCollection" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Microsoft.Windows.Server.2016.AD.ActiveDirectoryWebServices.Error.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.The_domain_controller_failed_to_obtain_a_new_account_identifier_pool_5_Rule" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!The_domain_controller_failed_to_obtain_a_new_account_identifier_pool_5_Rule" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Duplicate_account_names_were_detected___one_account_has_been_renamed_5_Rule" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Duplicate_account_names_were_detected___one_account_has_been_renamed_5_Rule" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.Windows.Server.2016.AD.DNSServer.Error.EventCollection" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainController.DNS" Enforced="false" Rule="MWSA6M!Microsoft.Windows.Server.2016.AD.DNSServer.Error.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.The_registry_policy_file_could_not_be_accessed_during_application_of_machine_policy_5_Rule" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!The_registry_policy_file_could_not_be_accessed_during_application_of_machine_policy_5_Rule" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Collection_Rule_for_No_DC_GC_in_Site_events_5_Rule" Context="MWSA6D!Microsoft.Windows.Server.2016.AD.DomainControllerRole" Enforced="false" Rule="MWSA6M!Collection_Rule_for_No_DC_GC_in_Site_events_5_Rule" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
    </Overrides>
  </Monitoring>
  <Presentation>
    <StringResources>
      <StringResource ID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Task.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Task.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Task.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyFailed.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyObjectsFiltered.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyFailed.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyObjectsFiltered.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDS.ComponentAlert.Report.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Event.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.Task.Alert.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.NotFound.Recovery.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.FoundRunning.Recovery.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.RecoveryFailed.Recovery.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.TooManyRecoveryAttempts.Recovery.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.AvailabilityState.Monitor.AlertMessage" />
    </StringResources>
  </Presentation>
  <LanguagePacks>
    <LanguagePack ID="ENU" IsDefault="false">
      <DisplayStrings>
        <DisplayString ElementID="Microsoft.Windows.Server.AD.2016.Monitoring.Addendum">
          <Name>Microsoft Windows Server ADDS 2016+ Monitoring Addendum</Name>
          <Description>
v1.0.4.7   5 Nov 2024 Updated report logic for open/closed and server naming conventions
v1.0.4.6  16 Jan 2024 Updated AD Team report DS/WA $Monitored variable typo for missing parenthesis
v1.0.4.5  21 Dec 2023 whitespace audit, ResolutionState changes, performance changes to DS/WA
v1.0.4.2  13 Dec 2023 Updated Rule closure logic, updated Group PolicyReport DS/WA, gpsvc service monitor
v1.0.4.1  12 Dec 2023 Updated reset logic to use Management Pack, removed ID property from reset logic
v1.0.3.9   6 Dec 2023 Removed Component Monitor,Rule, added hourly WA, Add time to reset monitor logic, Resolve-SCOMAlert for Component alert ZERO findings
v1.0.3.7  28 Nov 2023 Updated Component Alert logic datasources, DisplayStrings
v1.0.3.6  23 Oct 2023 Updated Scheduler variable, EndTime for componentAlert script datasource
v1.0.3.4  11 Jul 2023 Component Alert DS/WA, Reports to Info, Disabled ATQ monitor for false positive alerts
v1.0.3.3   6 Jul 2023 Updated GroupPolicyClient Recovery and rules
v1.0.3.1  29 Jun 2023 ADDS Component alert script DS/WA
v1.0.2.9  24 Apr 2023 Updated overrides disabling event collection, ATQ to warning, disable site availablity rollup
v1.0.2.4  10 Jun 2022 Added Group Policy alerts
v1.0.2.2   6 Jun 2022 Updated AD Team report, variables, agent check, override ID's, separated cleanup and reports
v1.0.1.4  31 Jan 2022 Updated reports, versions, NEW alerts
v1.0.1.2   2 Dec 2021 Updated for standards, select to select-string
v1.0.1.0   5 May 2021 Updated DS/WA with additional AD report breakout detail
v1.0.0.11 16 Apr 2021 Updated auto-close report, rule names
v1.0.0.5  18 Mar 2021 Test for alerts before resetting, typos, versioned scripts, updated task names
v1.0.0.3  17 Mar 2021 Updated with auto-closure logic and daily ADDS reports
v1.0.0.0  10 Jan 2018 Created additional Alert Functionality, Service Recovery Tasks</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.Close.Script.DataSource">
          <Name>Proactive DailyTasks ADDSAlerts report and auto-close DataSource</Name>
          <Description>This datasource generates ADDSAlerts report and auto-close DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.DataSource">
          <Name>Proactive DailyTasks ADDSAlerts Summary Report and auto-close DataSource</Name>
          <Description>This datasource generates ADDSAlerts summary report and auto-close DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.Datasource">
          <Name>Proactive DailyTasks AD Team daily report DataSource</Name>
          <Description>This datasource generates AD Team daily report PowerShell script DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.GroupPolicyReport.Script.DataSource">
          <Name>Proactive DailyTasks ADDS GroupPolicy Report alert script DataSource</Name>
          <Description>This datasource generates ADDS GroupPolicy Report alert script DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.DataSource">
          <Name>Proactive DailyTasks ADDS Component alert script DataSource</Name>
          <Description>This datasource generates ADDS Component alert script DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Alert.WA">
          <Name>Proactive DailyTasks ADDSAlerts report and auto-close on-demand task</Name>
          <Description>This write-action task generates ADDSAlerts report and auto-close DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.WA">
          <Name>Proactive DailyTasks ADDSAlerts summary report on-demand task</Name>
          <Description>This write-action task generates ADDSAlerts summary report write action</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.Addendum.AD.2016.Reports.WA">
          <Name>Proactive DailyTasks AD Team daily report on-demand task</Name>
          <Description>This write-action task generates AD Team daily report PowerShell script (WA) write action</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.WA">
          <Name>Proactive DailyTasks AD Component Alert Script report on-demand task</Name>
          <Description>This write-action task generates ADDS ComponentAlert report PowerShell script (WA) write action</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Rule.WA">
          <Name>Proactive DailyTasks ADDS Component Hourly PowerShell rule Write Action</Name>
          <Description>This datasource generates ADDS Component hourly alert</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.ADDS.Repeated.Event.MonitorType">
          <Name>Proactive DailyTasks ADDS Repeated Event MonitorType</Name>
          <Description>This MonitorType changes event monitor to Count Logic - counts x events in y time specified</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.ADDS.Service.Monitor.MonitorType">
          <Name>Proactive ADDS Service Monitor MonitorType</Name>
          <Description>This monitor type refers to datasource that adds options service monitor logic</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Alert.Rule">
          <Name>Proactive DailyTasks ADDSAlerts Auto-close Report Script Alert Rule</Name>
          <Description>Proactive Scheduled rule to kick off datasource at 0615 M-F</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDSAlerts Auto-close Report Script Alert Rule</Name>
          <Description>{1}

{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Task.Alert.Rule">
          <Name>Proactive DailyTasks ADDSAlerts task Report Manual Task Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.Close.Script.Task.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDSAlerts Report Script Manual Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.Rule">
          <Name>Proactive DailyTasks ADDSAlerts Summary Report Script Alert Rule</Name>
          <Description>Proactive Scheduled rule to kick off summary datasource at 0615 M-F</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDSAlerts Summary Report Script Alert Rule</Name>
          <Description>{1}

{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Task.Alert.Rule">
          <Name>Proactive DailyTasks ADDSAlerts Summary Report Manual Task Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Task.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDSAlerts Summary Report Script Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Alert.Rule">
          <Name>Proactive DailyTasks AD Team Report Script Alert Rule</Name>
          <Description>Proactive Scheduled rule to kick off datasource after 0600 M-F</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks AD Team Report Script Alert Rule</Name>
          <Description>{1}

{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Task.Alert.Rule">
          <Name>Proactive DailyTasks AD Team Report Script Report Manual Task Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.Addendum.AD.2016.Report.Script.Task.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks AD Team Report Script Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyFailed.Alert.Rule">
          <Name>Proactive DailyTasks ADDSAlerts 2016+ GroupPolicyFailed Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyFailed.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDSAlerts 2016+ GroupPolicyFailed Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyObjectsFiltered.Alert.Rule">
          <Name>Proactive DailyTasks ADDSAlerts 2016+ GroupPolicyObjectsFiltered Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS2016Alerts.GroupPolicyObjectsFiltered.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDSAlerts 2016+ GroupPolicyObjectsFiltered Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyFailed.Alert.Rule">
          <Name>Proactive DailyTasks ADDSAlerts 2016+ DC GroupPolicyFailed Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyFailed.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDSAlerts 2016+ DC GroupPolicyFailed Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyObjectsFiltered.Alert.Rule">
          <Name>Proactive DailyTasks ADDSAlerts 2016+ DC GroupPolicyObjectsFiltered Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS2016Alerts.DC.GroupPolicyObjectsFiltered.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDSAlerts 2016+ DC GroupPolicyObjectsFiltered Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Report.Script.Alert.Rule">
          <Name>Proactive DailyTasks ADDS ComponentAlert Report Script Alert Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Report.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDS ComponentAlert Report Script Alert Rule</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.Task.Alert.Rule">
          <Name>Proactive DailyTasks ADDS ComponentAlert Script Task Alert Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.Task.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks ComponentAlert Script Alert Rule</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Rule">
          <Name>Proactive DailyTasks ADDS ComponentAlert Hourly Script Alert Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Event.Rule">
          <Name>Proactive DailyTasks ADDS ComponentAlert Hourly Script Event Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Hourly.TimedPowerShell.Event.Rule.AlertMessage">
          <Name>Proactive DailyTasks ADDS ComponentAlert Hourly Script Event Rule Alert</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.NotFound.Recovery.Rule">
          <Name>Microsoft Windows Server 2016 GroupPolicyClient Service Recovery Failed - Service Not Found Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.NotFound.Recovery.Rule.AlertMessage">
          <Name>Microsoft Windows Server 2016 GroupPolicyClient Service Recovery Failed - Service Not Found</Name>
          <Description>Event Description: {0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.FoundRunning.Recovery.Rule">
          <Name>Microsoft Windows Server 2016 GroupPolicyClient Service Failed - Service Already Running Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.FoundRunning.Recovery.Rule.AlertMessage">
          <Name>Microsoft Windows Server 2016 GroupPolicyClient Service Recovery Failed - Service Already Running</Name>
          <Description>Event Description: {0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.RecoveryFailed.Recovery.Rule">
          <Name>Microsoft Windows Server 2016 GroupPolicyClient Service Recovery Failed - Service is not running Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.RecoveryFailed.Recovery.Rule.AlertMessage">
          <Name>Microsoft Windows Server 2016 GroupPolicyClient Service Recovery Failed - Service is not running</Name>
          <Description>Event Description: {0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.TooManyRecoveryAttempts.Recovery.Rule">
          <Name>Microsoft Windows Server 2016 GroupPolicyClient Service Recovery has attempted to recover the service too many times Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.TooManyRecoveryAttempts.Recovery.Rule.AlertMessage">
          <Name>Microsoft Windows Server 2016 GroupPolicyClient Service Recovery has attempted to recover the service too many times</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.Report.Script.Task">
          <Name>Proactive DailyTasks ADDSAlerts Autoclose Report Script Task</Name>
          <Description>Proactive DailyTasks ADDSAlerts AutoClose task to kick off on-demand</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDSAlerts.SummaryReport.Script.Task">
          <Name>Proactive DailyTasks ADDSAlerts Summary Report Script Task</Name>
          <Description>Proactive DailyTasks ADDSAlerts SummaryReport task to kick off on-demand</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.AD.2016.Team.Report.Script.Task">
          <Name>Proactive DailyTasks ADDSAlerts AD Team Report Script Task</Name>
          <Description>Proactive DailyTasks ADDSAlerts AD Team task to kick off on-demand</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.ADDS.ComponentAlert.Script.Task">
          <Name>Proactive DailyTasks ADDS ComponentAlert Script Task</Name>
          <Description>Proactive DailyTasks ADDS ComponentAlert Script task to kick off on-demand</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.AvailabilityState.Monitor">
          <Name>Group Policy Client service not running gpsvc Addendum Service Monitor</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.AvailabilityState.Monitor" SubElementID="Running">
          <Name>Running</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.AvailabilityState.Monitor" SubElementID="NotRunning">
          <Name>Not Running</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.GroupPolicyClient.Service.AvailabilityState.Monitor.AlertMessage">
          <Name>Group Policy Client service not running gpsvc Addendum Service Monitor Is Not Running</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="DFS.Service.Recovery.Task">
          <Name>Recover 'DFS Namespace' Service</Name>
          <Description>Created 2018-01-10 for Service Recovery Task</Description>
        </DisplayString>
        <DisplayString ElementID="NTDS.Service.Recovery.Task">
          <Name>Recover 'NTDS' Service</Name>
          <Description>Created 2018-01-10 for Service Recovery Task</Description>
        </DisplayString>
        <DisplayString ElementID="DFSR.Service.Recovery.Task">
          <Name>Recover 'DFS Namespace' Service</Name>
          <Description>Created 2018-01-10 for Service Recovery Task</Description>
        </DisplayString>
        <DisplayString ElementID="IsmServ.Service.Recovery.Task">
          <Name>Recover 'Inter-site Messaging' Service</Name>
          <Description>Created 2018-01-10 for Service Recovery Task</Description>
        </DisplayString>
        <DisplayString ElementID="KDC.Service.Recovery.Task">
          <Name>Recover 'Kerberos Key Distribution Center' Service</Name>
          <Description>Created 2018-01-10 for Service Recovery Task</Description>
        </DisplayString>
        <DisplayString ElementID="NetLogon.Service.Recovery.Task">
          <Name>Recover 'Netlogon' Service</Name>
          <Description>Created 2018-01-10 for Service Recovery Task</Description>
        </DisplayString>
        <DisplayString ElementID="W32Time.Service.Recovery.Task">
          <Name>Recover 'Windows Time' Service</Name>
          <Description>Created 2018-01-10 for Service Recovery Task</Description>
        </DisplayString>
        <DisplayString ElementID="GroupPolicy.Service.Recovery.Task">
          <Name>Recover 'Group Policy Client' Service</Name>
          <Description>Created 2018-01-10 for Service Recovery Task</Description>
        </DisplayString>
        <DisplayString ElementID="ADWS.Service.Recovery.Task">
          <Name>Recover 'Active Directory Web Services' Service</Name>
          <Description>Created 2018-01-10 for Service Recovery Task</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.Windows.Server.2016.AD.Configuration.ReplicationPartnerCount.Monitor">
          <Name>NotUsed</Name>
          <Description>3 Mar 2022 - KWJ - Overriding Replication Partner Count monitor to reflect AD design</Description>
        </DisplayString>
        <DisplayString ElementID="Override.IntervalSeconds.Microsoft.Windows.Server.2016.AD.Performance.GCResponse.Monitor">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - Changing interval to 15 minutes (900s)</Description>
        </DisplayString>
        <DisplayString ElementID="Override.IntervalSeconds.Microsoft.Windows.Server.2016.AD.Availability.GCResponse.Monitor">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - setting interval to 918</Description>
        </DisplayString>
        <DisplayString ElementID="Override.NumSamples.Microsoft.Windows.Server.2016.AD.Performance.GCResponse.Monitor">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - setting samples to 4 (hourly)</Description>
        </DisplayString>
        <DisplayString ElementID="Override.A_RSoP__Resultant_Set_of_Policies__error_occurred_5_Rule">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - Disabling Events duplicate to alerts</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.Windows.Server.2016.AD.DirectoryService.Error.EventCollection">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - Disabling AD event rule</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Unexpected_SAM_Failure_5_Rule">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - Disabling ADDS event rule</Description>
        </DisplayString>
        <DisplayString ElementID="Override.PAC_Verification_Failure_5_Rule">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - Disabling ADDS event rule</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.Windows.Server.2016.AD.DFSReplication.Warning.EventCollection">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - Disabling ADDS event rule</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.Windows.Server.2016.AD.DirectoryService.Warning.EventCollection">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - Disabling ADDS event rule</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.Windows.Server.2016.AD.DFSReplication.Error.EventCollection">
          <Name>NotUsed</Name>
          <Description>9 Mar 2022 - KWJ - Disabling ADDS event rule</Description>
        </DisplayString>
        <DisplayString ElementID="Override.IntervalSeconds.Microsoft.Windows.Server.2016.AD.Configuration.NetworkAdapters.DNS.Monitor">
          <Name>NotUsed</Name>
          <Description>10 Mar 2022 - KWJ - Changing interval to 902 from 300</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Machine_account_policy_failure___Active_Directory_GPO_lookup_failure_5_Rule">
          <Name>NotUsed</Name>
          <Description>15 Mar 2022 - KWJ - Disabling ADDS event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Windows_cannot_obtain_the_domain_controller_name_for_your_computer_network._5_Rule">
          <Name>NotUsed</Name>
          <Description>15 Mar 2022 - KWJ - Disabling ADDS event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.Windows.Server.2016.AD.ActiveDirectoryWebServices.Error.EventCollection">
          <Name>NotUsed</Name>
          <Description>15 Mar 2022 - KWJ - Disabling ADDS event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.The_domain_controller_failed_to_obtain_a_new_account_identifier_pool_5_Rule">
          <Name>NotUsed</Name>
          <Description>17 Mar 2022 - KWJ - Disabling AD event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Duplicate_account_names_were_detected___one_account_has_been_renamed_5_Rule">
          <Name>NotUsed</Name>
          <Description>17 Mar 2022 - KWJ - Disabling AD Event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.Windows.Server.2016.AD.DNSServer.Error.EventCollection">
          <Name>NotUsed</Name>
          <Description>29 June 2022 - KWJ - Disabling AD DNS event logging</Description>
        </DisplayString>
        <DisplayString ElementID="Override.The_registry_policy_file_could_not_be_accessed_during_application_of_machine_policy_5_Rule">
          <Name>NotUsed</Name>
          <Description>29 June 2022 - KWJ - Disabling ADDS events</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.Windows.Server.2016.AD.Configuration.NetworkAdapters.DNS.Monitor">
          <Name>NotUsed</Name>
          <Description>17 Nov 2022 - KWJ - Disabling as DC's are single NIC</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Collection_Rule_for_No_DC_GC_in_Site_events_5_Rule">
          <Name>NotUsed</Name>
          <Description>18 Nov 2022 - KWJ - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.Windows.Server.AD.Library.Site.AvailRollupMonitor">
          <Name>NotUsed</Name>
          <Description>18 Nov 2022 - KWJ - Disable AD site rollup</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Severity.Microsoft.Windows.Server.2016.AD.Performance.Atq.AvgThreads.Monitor">
          <Name>NotUsed</Name>
          <Description>13 Apr 2023 - NOT critical alert, perforrmance related concern</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.Windows.Server.2016.AD.Performance.Atq.AvgThreads.Monitor">
          <Name>NotUsed</Name>
          <Description>10 Jul 2023 - Disabling false positive alert</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.Windows.Server.2016.AD.AvailabilityEssentialService.GroupPolicy.ServiceCheck.Monitor">
          <Name>NotUsed</Name>
          <Description>20 Dec 2023 - Disabled AD pack monitor for addendum service monitor</Description>
        </DisplayString>
      </DisplayStrings>
    </LanguagePack>
  </LanguagePacks>
</ManagementPack>